### Template Instantiation
- 템플릿 인스턴스화란, 템플릿 파라미터를 구체적인 값이나타입으로 대체하는 과정을 말합니다. 
- 컴파일러는 템플릿 인스턴스화 과정을 통해 각 템플릿 인스턴스에 대해 함수구현을 자동으로 생성합니다.
- 템플릿 인스턴스화는 다음과 같은 이점이 있습니다.
	- 하나의 템플릿으로 다양한 타입을 처리할 수 있습니다.
	- 중복된 코드를 줄이고 유지 보수성을 높입니다.
	- 컴파일러는 각 타입에 대해 최적화된 코드를 생성합니다.
```C++
	template<typename T>
	T add(T a, T b){
	return a+b;
	}

	add(3,4) // int타입으로 인스턴스화 되어 int add(int,int) 를 생성합니다.
add(3.0f, 4.0) //float 타입으로 인스턴스화 되어, float add(float, float)를 생성합니다.
add(2,6)// 이미 int add(int,int)가 있기에 이를 재사용합니다. 
//예를들어 char add(char,char)는 호출되지 않았으므로 생성되지 않습니다. 
```

### Implicit and Explicit Template Instantiation 
- 암시적 템플릿 인스턴스화
	- 컴파일러가 함수 호출시, 인수의 타입을 추론하여 **필요한 경우에만** 템플릿 인스턴스를 생성하는 방식을 말합니다.
	- 컴파일러는 필요할때마다 적절한 템플릿 인스턴스를 자동으로 생성합니다.
- 명시적 템플릿 인스턴스화 
	- 코드에서 **직접 명시적으로 템플릿 인스턴스를 생성**하는 방식입니다.
	- 이는 주로 여러 translation units에서 바이너리 크기를 줄이기 위해 사용됩니다.
```C++
template<typename T>
T f(T a) { return a * 2; }

template void f<int>(int);
template void f<short>(short); 

float g()
{
	f(3);// int 타입으로 암시적으로 인스턴스화 
	return f<float>(3); //float 타입으로 명시적 인스턴스화
}
int main() {

	int a;
	a = g();
	std::cout << a;
}

```
### Template Parameters
- 템플릿 파라미터는 템플릿 키워드에 뒤에 따라 붙는 이름들로, 템플릿을 정의할때 사용합니다.
- 템플릿 파라미터는 제네릭 타입을 나타내고, 템플릿 인스턴스화 시, 구체적인 타입이나 값으로 대체됩니다. 
- 템플릿 파라미터의 종류는 다음과 같습니다.
	- **타입 템플릿 파라미터** (Type Template Parameter)
		- `typename` 키워드를 사용하여 타입 템플릿 파라미를 정의합니다.
	- **비타입 템플릿 파라미터**(NTTP: Non-Type Template Parameter)
		- 템플릿을 인스턴스화 할때 구체적인 값을 제공해합니다.
		- `int,` `enum` 등 비타입 값을 템플릿 파라미터로 정의할 수 있습니다. 
		- 코드 인라이닝 수행을 통한 컴파일러 최적화 가능
	
	```C++
		template<int N>
		int factorial(){
		return (N<=1)? : 1 : N * factorial<N-1>();
		}
		int fact5 = factorial<5>();
	```
### 템플릿 사용 예시
```C++
// 컴파일 타임에 계산되어 런타임에 추가연산이 필요없습니다.
template<int A, int B>
int add_int() {
    return A + B; // 합은 컴파일 타임에 계산됨
}

// 사용 예시
int result = add_int<3, 4>(); // result는 7

```

```C++
//enum 파라미터 템플
template<int A, int B>
int add_int() {
    return A + B; // 합은 컴파일 타임에 계산됨
}

// 사용 예시
int result = add_int<3, 4>(); // result는 7

```

```C++ 
template<int DIV, typename T>
T ceil_div(T value) {
    return (value + DIV - 1) / DIV;
}

// 사용 예시
int ceilResult = ceil_div<5>(11); // ceilResult는 3

```

- Rounded Division
```C++
template<int DIV, typename T>
T round_div(T value){
	return (value + DIV / 2) / DIV;
}
```