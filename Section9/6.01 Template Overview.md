### Template
- C++에서 제네릭 프로그래밍을 위한 메커니즘입니다.
- `schema` 혹은 `placeholders`를 제공합니다.
- 템플릿은 컴파일 타임에 작동하며, 다음과 같은 엔터티의 가족을 나타낼 수 있습니다.
	- A family of functions
	- A family of classesa
	- A family of variables (C++ 14)
### Template 사용배경
- 함수 오버로딩을 사용할 때, 아래 코드와 같은경우 중복된 코드가 많이 발생합니다
```C++
int add(int a, int b) { return a + b; }
float add(float a, float b) { return a + b; } // 오버로딩
char add(char a, char b) { return a + b; } // 오버로딩
ClassX add(ClassX a, ClassX b) { return a + b; } // 오버로딩
```
- Template을 사용하는 경우, 하나의 함수 템플렛으로 여러 타입을 처리할 수 있습니다
```C++
template <typename T>
	T add(T a, T b){
	return a + b;
}

int main() {
		
	int c1 = add(3, 4);
	float c2 = add(3.14f, 1.12f);

	std::cout << c1 << " " << c2; 
}
```
### Template 사용의 장단점
- 템플릿은 C++ 에서 제네릭프로그래밍을 가능하게 하며, 코드의 재사용성과 유지보수성을 향상시키는 강력한 도구입니.
- 그러나 주의해야할 단점도 있으며, 장단점을 정리하자면 다음과 같습니다.
- **장점**
	- 제네릭 프로그래밍
		- 코드 감소 및 재사용성 증가
		- 중복제거
		- 유연성
	- 성능
		- 컴파일 타임 최적화
			- 컴파일 타임에 인스턴스화 되므로, 컴파일러 최적화를 수행할 수 있으며, 이는 런타임에 더 빠른성능을 기대할 수 있습니다.
		- 컴파일 타임 계산
			- 위와 마찬가지로 컴파일 타임에 계산을 수행할 수 있어, 런타임 오버헤드를 줄일 수 있습니다. 
- **단점**
	- 가독성
		- 복잡한 문법
			- 기존 c++ 프로그래밍보다 문법이 난해할 수 있습니다.
		- 난해한 에러메세지
			- 컴파일 에러메세지가 상대적으로  종종 길고 이해하기 어려워 질 수 있습니다. 
	- 컴파일 시간 및 바이너리 크기
		- 템플릿은 여러타입에 대해 인스턴스화 됩니다 따서 컴파일시간이 길어질 수 있습니다.
		- 각기 다른 템플릿 인스턴스는 별도의 코드로 컴파ㄹ 되기에 바이너리 크기가 커질 수 있습니다. 
