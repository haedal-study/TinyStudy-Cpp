# [Function Pointers and Function Objects]

## 함수 포인터

함수 포인터의 개념을 통해 제네릭 프로그래밍 기능과 합성 가능성을 달성함
- 함수는 다른 함수에 대한 포인터로 전달될 수 있으며 "간접 호출(indirect call)"로 작동함
- 예 (qsort 함수)
  - qsort 함수는 배열을 정렬하는 데 사용됨
  - 이때, 정렬 방법을 지정하기 위해 비교함수가 필요함 -> 함수 포인터를 사용하여 qsort에 비교함수가 전달됨
  ~~~cpp
  #include <stdlib.h> // qsort
  
  // 내림차순으로 정렬하는 비교 함수
  int descending(const void* a, const void* b) {
      return *((const int*) b) - *((const int*) a);
  }
  
  int main() {
      int array[] = {7, 2, 5, 1};
      qsort(array, 4, sizeof(int), descending);
      // array: { 7, 5, 2, 1 } (내림차순으로 정렬됨)
      return 0;
  }
  ~~~

- 다른 함수의 인수로 전달될 수 있음
  - 이는 일반적인 경우에 사용되는데, 함수가 다른 함수에 의해 호출될 때 사용됨
- 예 (eval 함수)
  - 함수 포인터를 매개변수로 받아들이고, 그 함수 포인터를 사용하여 두 개의 숫자를 조작함
  ~~~cpp
  // 세 개의 매개변수를 받아 f를 사용하여 a와 b 조작하고 결과 반환
  int eval(int a, int b, int (*f)(int, int)) {
      return f(a, b);
  }
  
  int add(int a, int b) { return a + b; }
  int sub(int a, int b) { return a - b; }
  
  int main() {
      cout << eval(4, 3, add); // 4와 3을 더함 (7 출력)
      cout << eval(4, 3, sub); // 4와 3을 뺌 (1 출력)
      return 0;
  }
  ~~~
  위와 같은 방식을 사용하여 함수를 전달하면   
  프로그램이 보다 유연하고 모듈화되며, 다양한 작업에 재사용할 수 있음   
  하지만, 이러한 접근 방식은 일반적인 문제점을 가질 수 있음   
  예를 들어, 안전성과 성능에 대한 문제가 있을 수 있음   

## 함수 객체

호출 가능한 객체로, 매개변수처럼 취급될 수 있는 것을 말함   
C++에서는 이를 통해 "프로시저"를 다른 함수로 전달하는 효율적이고 편리한 방법을 제공함   

- 예 (std::sort 함수)
  - 비교 함수를 인자로 받아들임
  - 이때 함수 객체를 사용하면 비교 동작을 수행할 수 있음

  ~~~cpp
  #include <algorithm> // for std::sort
  
  struct Descending { // 함수 객체
      bool operator()(int a, int b) { // 함수 호출 연산자
          return a > b;
      }
  };

  int array[] = {7, 2, 5, 1};
  std::sort(array, array + 4, Descending{}); // 내림차순으로 배열을 정렬
  // array: { 7, 5, 2, 1 }
  ~~~

- 함수 객체의 장점

  - 안전성
  	- 매개변수의 유형을 항상 확인할 수 있음
  	- 템플릿을 포함할 수 있음
  - 성능
  	- 컴파일러는 대상 함수의 코드에 operator()를 삽입한 다음 루틴을 컴파일함
  	- 이러한 최적화 기법은 표준 동작임 => 함수 호출 오버헤드가 줄어듬

또한, C++11은 이러한 개념을 더 간단하게 만들어주는 람다 표현식이라는 덜 번거로운 함수 객체를 제공함
