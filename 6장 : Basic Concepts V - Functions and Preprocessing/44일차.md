# [Capture List]

## 람다 표현식

함수 객체를 생성하고 인라인화할 때 간결한 구문을 사용할 수 있음   
C++11에서 도입된 인라인 지역 스코프 함수 객체임   
~~~cpp
auto x = [캡처절] (매개변수) { 본문 };
~~~
[캡처 절]
- 람다의 선언을 표시하고 로컬 스코프 인수가 어떻게 캡처되는지 지정함 (값 또는 참조로 등)

매개변수
- 람다의 매개변수로서 일반적인 함수 매개변수임 (선택사항)

본문
- 람다의 본문은 일반 함수 본문임

=
- 오른쪽의 표현식이 람다 표현식이며, 해당 표현식으로 생성된 런타임 객체 x는 클로저임
- **클로저 : 해당 람다 표현식의 실행 환경을 캡처하고 저장하는데, 이는 표현식에서 참조하는 외부 변수 및 함수 등을 포함함

코드 즐록을 익명의 함수 객체로 변환하는 간편한 방법임   
주로 알고리즘 함수와 함께 사용되어 인라인으로 사용됨   

~~~cpp
#include <algorithm> // for std::sort
int array[] = {7, 2, 5, 1};

// 이름이 지정된 람다 함수
auto lambda = [](int a, int b){ return a > b; };
std::sort(array, array + 4, lambda); // array: { 7, 5, 2, 1 }

// 이름이 지정되지 않은 람다 함수
std::sort(array, array + 4, [](int a, int b){ return a > b; }); // array: { 7, 5, 2, 1 }
~~~

## 캡처 리스트

람다 바디에서 사용되는 외부 변수를 두가지 방식으로 캡처함
- 값에 의한 캡처
- 참조에 의한 캡처 (외부 변수 값 수정 가능)

캡처 리스트는 다음과 같이 전달 가능
- []: 캡처 없음
- [=]: 모든 변수를 값에 의해 캡처
- [&]: 모든 변수를 참조에 의해 캡처
- [var1]: var1만 값을 통해 캡처
- [&var2]: var2만 참조에 의해 캡처
- [var1, &var2]: var1은 값으로, var2는 참조로 캡처

~~~cpp
# include <algorithm> // for std::find_if
int limit = ...
auto lambda1 = [=](int value) { return value > limit; }; // 값에 의한 캡처
auto lambda2 = [&](int value) { return value > limit; }; // 참조에 의한 캡처
auto lambda3 = [limit](int value) { return value > limit; }; // "limit" 값을 통한 캡처
auto lambda4 = [&limit](int value) { return value > limit; }; // "limit" 참조를 통한 캡처
// auto lambda5 = [](int value) { return value > limit; }; // 캡처 없음, 컴파일 오류
int array[] = {7, 2, 5, 1};
std::find_if(array, array + 4, lambda1);
~~~

캡처 리스트는 람다 표현식의 유연한 사용을 가능하게 함
- 특정 상황에 맞게 적절한 캡처 방식을 선택할 수 있음
~~~cpp
// [=, &var1]는 var1을 제외한 람다의 몸체에서 사용된 모든 변수를 값으로 캡처하고,
// var1은 참조로 캡처합니다.
auto lambda1 = [=, &var1]() { /* 본문 */ };

// [&, var1]는 var1을 제외한 람다의 몸체에서 사용된 모든 변수를 참조로 캡처하고,
// var1은 값으로 캡처합니다.
auto lambda2 = [&, var1]() { /* 본문 */ };

// constexpr 변수는 캡처하지 않고도 람다 표현식 내에서 읽을 수 있습니다.
constexpr int limit = 5;
int var1 = 3, var2 = 4;
auto lambda3 = [](int value){ return value > limit; };
auto lambda4 = [=, &var2]() { return var1 > var2; };
~~~
