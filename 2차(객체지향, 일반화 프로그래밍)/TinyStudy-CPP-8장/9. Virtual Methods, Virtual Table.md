
### Virtual Method
---

- 가상 메서드(virtual method)는 `virtual` 키워드를 붙인 메서드이다. 부모 클래스에서 선언된 가상 메서드는 자식 클래스에서 재정의 할 수 있다.
```cpp
struct A {
	virtual void f() { cout << "A"; }
};

struct B : A {
	void f() { cout << "B"; } // virtual을 붙여도 됨. 가상 함수라는 것이 가독성있게 전달될 수 있음.
};

void g(A& a) { a.f(); }

int main() {
	A a;
	B b;
	g(a); // print A
	g(b); // print B
}
```


- 가상 함수는 자식 객체를 부모 객체에 참조나 포인터로 할당할 때에만 사용할 수 있다. 
	- 값으로 전달할 경우 객체 슬라이싱 발생하여 자식 객체에서 재정의한 함수를 가져오지 못함.
- 객체 슬라이싱(object slicing) : 부모 타입 객체에 자식 타입 객체를 할당할 때 발생. 자식 클래스에 선언한 멤버 변수나 메서드가 부모 객체에 복사되지 않는다.

```cpp
struct A {
	virtual void f() { cout << "A"; }
};

struct B : A {
	void f() { cout << "B"; } // virtual을 붙여도 됨.
};

void g(A& a) { a.f(); }
void h(A* a) { a->f(); }
void i(A a) { a.f(); }

int main() {
	B b;
	g(b); // print B
	h(&b); // print B
	i(b); // print A
}
```


### Virtual Table
---

- 가상함수 테이블(virtual table, vtable)은 함수 호출을 해결하고 늦은 바인딩을 위해 필요한 함수 테이블을 의미한다.

- 가상함수 테이블에는 해당 클래스에서 호출될 수 있는 가장 하위(most-derived)의 가상 함수들이 함수 포인터 형태로 들어있다.
- 객체에서 가상함수를 호출할 때 해당 객체의 클래스의 가상함수 테이블을 참조해 함수를 호출한다.
- 가상함수가 있는 클래스에는 가상함수 테이블을 가리키는 **포인터**가 (컴파일러에 의해)자동으로 들어가게 된다. 이를 `sizeof()`를 통해 확인할 수 있다.
- 부모 클래스에 있는 vtable 포인터는 자식 클래스로 상속되지만 자식 클래스의 vtable을 가리키게 된다.

![[Pasted image 20240525135516.png]]

```cpp
struct A {
	virtual void f() {}
	virtual void g() {}
	virtual void h() {}
};

cout << sizeof(A); // x64 : 8, x86 : 4
```


참고자료

https://stackoverflow.com/questions/5821075/why-do-virtual-functions-need-to-be-passed-with-a-pointer-and-not-by-valueof-th
https://en.wikipedia.org/wiki/Object_slicing

