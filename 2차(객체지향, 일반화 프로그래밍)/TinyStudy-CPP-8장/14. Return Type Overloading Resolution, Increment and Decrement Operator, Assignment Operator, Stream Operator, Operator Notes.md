
### Return Type Overloading Resolution
---

- 다음과 같이 객체의 리턴 타입을 오버로딩하여 바꿀 수 있다.
```cpp
struct A {
	operator float() { return 3.0f; }
	operator int() { return 2; }
};

A f() {
	return A{};
}

float a = f();
int b = f();
cout << a << " " << b; // print "3 2"
```


### Increment and Decrement Operator
---

- 증감 연산자(++, --)를 오버로딩 할 수 있다.
```cpp
struct A {
	int x = 0;
	A& operator++() { // 전위(++A)
		++x;
		return *this; // 새롭게 계산된 값을 reference로 리턴
	}
	A operator++(int) { // 후위(A++)
		A tmp = *this;
		++x;
		return tmp; // 계산 이전의 값을 value으로 리턴
	}
};

A a;
cout << a++.x; // print 0
cout << ++a.x; // print 2
```


### Assignment Operator
---

- 할당 연산자(`operator=`)를 오버로딩해 이미 존재하는 객체에 다른 객체의 정보를 복사할 수 있다.
- 유의해야 할 것
	- 자기 자신을 할당하는 것 주의
	- 복사하기 전에 갖고 있던 객체의 리소스 해제
	- 깊은 복사하기

```cpp
struct Array {
	int size;
	char* array;

	Array(int size1, char value) :size(size1) {
		array = new char[size];
		std::fill(array, array + size, value);
	}
	~Array() { delete[] array; }

	Array& operator=(const Array& x); // operator= 오버로딩
};

Array& Array::operator=(const Array& x)
{
	if (this == &x) // 자기 자신을 복사하는지 확인
		return *this;
	delete[] array; // 갖고 있던 자원 해제
	size = x.size;
	array = new char[x.size];
	std::copy(x.array, x.array + size, array); // 깊은 복사
	return *this;
}

Array a{ 5, 'd' };
Array b{ 3, 'c' };
a = b;
for (int i = 0; i < a.size; ++i)
	cout << a.array[i]; // print "ccc"
```

- 다음과 같이 `swap`함수를 사용해 구현할 수도 있다.
- 이 때에는 해당 클래스를 위한 swap 함수를 새로 정의해줘야 할 수 있다.
```cpp
// 클래스 범위 밖에서 클래스의 멤버를 수정하기 위해 friend로 정의
friend void swap(Array& x, Array& y) { 
	using std::swap; 
	swap(x.size, y.size); 
	swap(x.array, y.array); 
}

Array& Array::operator=(Array x) { // pass by-value 
	swap(*this, x);
	return *this; // x는 함수 종료와 함께 사라짐
}
```


### Stream Operator `operator<<`
---

- 스트림 연산자(`operator<<`)를 오버로딩하여 객체의 입출력을 정의할 수 있다.
- 오버로딩을 위해 입출력 스트림 클래스가 필요하기 때문에 `friend` 함수로 정의하여 스트림 클래스를 사용해야 한다.
- 파라미터로 스트림 객체를 참조로 받고, 받은 객체를 참조로 리턴한다.
```cpp
struct Point {
	int x, y;
	Point(int x1, int y1) : x(x1), y(y1) {}

	friend std::ostream& operator<<(std::ostream& stream, const Point& point) {
		stream << "(" << point.x << ", " << point.y << ")";
		return stream;
	}

	friend std::istream& operator>>(std::istream& stream, Point& point) {
		int x1, y1;
		cin >> x1 >> y1;
		point.x = x1;
		point.y = y1;
		return stream;
	}
};

Point p{ 1,2 };
cout << p; // print "(1, 2)"
cin >> p;  // input : 2, 3
cout << p; // print "(2, 3)"
```


### Operators Precedence
---

- 연산자들의 우선순위는 연산자 오버로딩을 하더라도 바뀌지 않는다.
```cpp
struct MyInt {
	int x;
	int operator^(int exp) { // 지수
		int ret = 1;
		for (int i = 0; i < exp; i++)
			ret *= x;
		return ret;
	}
};

MyInt x{ 3 };
int y = x ^ 2; // y = 9
int z = x ^ 2 + 2;
cout << z; // z = 81
```

- 위 코드에서 연산자`^`는 비트 연산으로 산술 연산보다 우선순위가 낮기 때문에 식이 다음과 같이 표현된다.
	- `z = x^(2+2)`


### Binary Operator Note
---

- 이항 연산자(Binary Operator)를 오버로딩 할 때에는 `friend` 키워드를 붙여 구현하는 것이 좋다.
- 타입이 다른 두 객체를 비교할 때, 하나의 클래스에만 이항 연산을 정의하면 다음과 같은 불편한 상황이 발생한다.
```cpp
struct A {}; struct C {};

struct B : A {
	bool operator==(const A& x) { return true; }
};

struct D : C {
	friend bool operator==(const C& x, const C& y) { return true; }
};

A a; B b; C c; D d;
b == a;
// a == b; "C++20 이전"에는 A에 == 연산자가 정의되지 않아 사용 불가.
c == d;
d == c;
```

