
### Hierarchy Casting
---

- 클래스 캐스팅(Class-casting)은 암시적이거나 명시적으로 클래스 계층 간의 형변환을 의미한다.

- 업캐스팅(Upcasting) : 자식 클래스(참조 or 포인터)에서 부모 클래스로의 형변환
	- 명시적/암시적으로 이루어짐
	- `static_cast`, `dynamic_cast`를 사용해 명시적 형변환 가능
	- 형변환이 안전함

- 다운캐스팅(Downcasting) : 부모 클래스(참조 or 포인터)에서 자식 클래스로의 형변환
	- 명시적으로 이루어짐
	- `static_cast`, `dynamic_cast`를 사용해 명시적 형변환 가능
	- 형변환이 위험함

- 사이드캐스팅(Sidecasting) : 같은 계층에 있는 클래스(참조 or 포인터) 간의 형변환
	- 명시적으로 이루어짐
	- 오직 `dynamic_cast`로만 명시적 형변환 가능
	- 형변환이 위험함

- upcasting, downcasting 예시
- 다운캐스팅 시, 부모 클래스에는 없는 속성을 참조할 경우 seg fault 오류가 발생한다.
```cpp
struct A {
	virtual void f() { cout << "A"; }
};

struct B : A { 
	int x = 3;
	void f() override { cout << "B"; }
};

int main() 
{
	A a;
	B b;
	A& a1 = b; // 암시적 업케스팅
	static_cast<A&>(b).f(); // 명시적 업케스팅. print B
	static_cast<B&>(a).f(); // 명시적 다운케스팅. print A
	cout << static_cast<B&>(a).x; // seg fault. print 이상한 값
}
```

- sidecasting 예시
```cpp
struct A {
	virtual void f() { cout << "A"; }
};

struct B1 : A { 
	void f() override { cout << "B1"; }
};

struct B2 : A {
	void f() override { cout << "B2"; }
};

int main() 
{
	B1 b1;
	B2 b2;
	// 아래는 사이드캐스팅
	dynamic_cast<B2&>(b1).f(); // 예외 발생. throw std::bad_cast
	dynamic_cast<B1&>(b2).f(); // 예외 발생. throw std::bad_cast
}
```

### RTTI(Run-time Type Information)
---

- RTTI(Run-time Type Information)은 런타임에 객체의 타입을 결정하도록 하는 메커니즘을 의미한다.
- RTTI는 다형성을 만족하는 클래스에 대한 개념으로, `virtual` 함수를 가진 클래스에 대해 작용한다.

- `dynamic_cast` 키워드 : 다형성 타입 간의 형변환을 해주는 키워드이다. 
- `typeid` 키워드 : 런타임에 참조or포인터가 가리키는 객체의 타입을 알려준다. `const std::type_info` 타입으로 리턴한다.
- `type_info` 클래스 : `typeid` 연산자의 반환값으로, 타입 정보를 가지고 있다.

```cpp
struct A {
	virtual void f() {}
};

struct B : A {};

int main() 
{
	A a;
	B b;
	A& a1 = b;
	// name() : const char* type_info::name() const
	cout << typeid(a).name();  // print "struct A"
	cout << typeid(b).name();  // print "struct B"
	cout << typeid(a1).name(); // print "struct B"
	cout << typeid(&a1).name();// print "struct A*"
}
```

#### `dynamic_cast`

- 런타임에 업, 다운, 사이드 캐스팅을 안전하게 수행시켜주는 연산자이다.
- 참조or포인터 타입을 사용해야 한다.
- dynamic_cast는 런타임에 타입 캐스팅이 가능한지 검사하고 비용이 크다.

- 속성
	- `dynamic_cast<New>(Obj)` : 업캐스팅의 경우 Obj 자리에 자식 클래스, New 자리에 부모 클래스를 둔다.
	- `New`, `Obj`가 참조일 때, 형변환이 불가능하면 `std::bad_cast` 예외를 발생시킨다.
	- `New`, `Obj`가 포인터일 때, 형변환이 불가능하면 `NULL`을 리턴한다.

```cpp
struct A {
	virtual void f() { cout << "A"; }
};

struct B : A {
	void f() override { cout << "B"; }
};

A* get_object(bool selectA) {
	return (selectA) ? new A() : new B();
}

void g(bool value) {
	A* a = get_object(value); // a에 B*가 할당되면 다운캐스팅 가능. 아님 불가능.
	B* b = dynamic_cast<B*>(a);
	if (b != nullptr) {
		b->f();
	}
}

g(true); // b가 null어서 출력x
g(false);// print 
```


참고자료
[typeid 연산자 (C++ 전용) - IBM Documentation](https://www.ibm.com/docs/ko/i/7.5?topic=expressions-typeid-operator-c-only)
