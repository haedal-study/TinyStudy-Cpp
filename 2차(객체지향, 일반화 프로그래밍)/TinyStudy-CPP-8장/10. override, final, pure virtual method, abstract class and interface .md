
### `override` Keyword
---

- 재정의 할 가상 함수에 `override`를 붙여줌으로써 이 함수가 가상 함수이고 재정의 한다는 것을 컴파일러에 전달해준다.
- 컴파일러는 `override`가 붙은 메서드가 부모 클래스의 가상 함수와 시그니처가 일치하는지 검사한다.
- `override` 키워드는 `virtual`을 내포하고 있으며 같이 쓰면 안된다.

### `final` Keyword
---

- `final` 키워드가 붙은 클래스 : 더 이상 상속될 수 없음을 나타낸다.
- `final` 키워드가 붙은 메서드 : 더 이상 재정의 할 수 없음을 나타낸다.

```cpp
struct A {
	virtual void f(int a) final;
};

struct B final : A {
	// void f(int a) override {}; // f(int)가 final이라 재정의 할 수 없음
	void f(float a) {} // 잘못 사용될 수 있음. override를 붙여 시그니처가 맞는지 확인하는게 중요
};

// struct C : B {}; // B가 final 클래스라 더이상 상속 불가
```


### 가상함수 사용 시 주의점
---

#### `virtual`메서드를 가지는 클래스는 꼭 소멸자도 `virtual`로 선언해야 한다.
	- 소멸자를 `virtual`로 선언하지 않으면, 자식 클래스의 소멸자가 호출되지 않는다.

```cpp
struct A {
	~A() { cout << "A"; }
	virtual void f(int a) {}
};

struct B final : A {
	int* array;
	B() { array = new int[100000]; }
	~B() { delete[] array; } // array가 해제되지 않아 메모리 낭비가 발생
};

void destroy(A* a) {
	delete a;
}

B* b = new B;
destroy(b); // print 'A' : A 소멸자가 호출됨
```

#### 생성자, 소멸자에 가상 메서드를 적으면 안 된다.

- 생성자에 적을 시 : 자식 클래스는 생성될 때, 부모 생성자를 먼저 호출한다. 자식 객체가 완전히 생성되기 전에 부모 객체에서 가상함수를 호출하기 때문에 자식 객체에서 재정의해도 적용되지 않고 부모 객체의 가상함수가 실행된다.
- 소멸자에 적을 시 : 자식 클래스의 소멸자가 먼저 호출되기 때문에 마찬가지로 자식 클래스가 재정의한 가상함수가 실행되지 않는다.


#### default parameter는 상속되지 않는다.

```cpp
#include <iostream>
using namespace std;

struct A {
	virtual void f(int i = 5) { cout << "A::" << i << "\n"; }
	virtual void g(int i = 5) { cout << "A::" << i << "\n"; }
};

struct B : A {
	void f(int i = 3) override { cout << "B::" << i << "\n"; }
	void g(int i) override { cout << "B::" << i << "\n"; }
};

int main() 
{
	A a;
	B b;
	a.f(); // A::5
	a.g(); // A::5

	A& ab = b;
	ab.f(); // B::5
	ab.g(); // B::5
}
```

- 위 코드의 `ab` 변수에서, A클래스의 vtable에는 `void f(int i = 5)`와 `void g(int i = 5)`를 갖고 있지만 B 객체를 할당했기 때문에 B 클래스의 `f`, `g` 함수 구현부를 가리킨다.
- 따라서 인자 i는 3이 아닌 5를 갖게 된다.


### 순수 가상 함수
---

- 순수 가상 함수(Pure Virtual Method)는 무조건 자식 클래스에서 재정의 해야하는 함수를 의미한다.
- 순수 가상 함수가 정의된 클래스는 인스턴스를 생성할 수 없다.
```cpp
struct A {
	virtual void f() = 0; // body 없이 순수 가상함수 선언
	virtual void g() = 0; // body가 있는 순수 가상함수
};
void A::g() {} // body

struct B : A {
	void f() override {}
	void g() override {}
};

// A a; // 순수 가상 함수가 존재하므로 객체 생성 불가
B b; // 순수 가상 함수를 전부 재정의하지 않으면 객체 생성 불가
```


### 추상 클래스와 인터페이스
---

- 추상 클래스(Abstract Class)는 순수 가상 함수를 적어도 하나는 가지고 있는 클래스이다.
	- 멤버 변수와 메서드의 구현을 가질 수 있다.
	- 자식 클래스에 공통적으로 필요한 코드(구현)를 공유하여 코드의 재사용성을 높일 수 있다.
	- 확장해야 할 기능들을 순수 가상 함수로 표현하여 사용할 수 있다.

- 인터페이스(Interface)는 순수 가상 함수와 virtual 소멸자로만 구성된 클래스이다.
	- 멤버 변수와 메서드의 구현이 없다.
	- 다양한 객체들의 공통된 기능을 인터페이스에 정의하고(추상화), 인터페이트 클래스를 상속하여 자식 클래스에서 구현하여 사용할 수 있다.
	- 인터페이스가 가진 메서드를 재정의 하도록 강제함으로써 필요한 기능을 구현하도록 약속할 수 있다.
	- 구현해야 할 기능들만 명시되어 있기에 상속받은 클래스가 보다 유연하게 구현할 수 있다.

```cpp
struct A { // Interface
	virtual ~A();
	virtual void f() = 0;
};

struct B { // abstract class
	B() {}
	virtual void g() = 0;
protected:
	int x;
};
```


참고자료
[인터페이스와 추상 클래스의 차이점 및 활용 방법 (f-lab.kr)](https://f-lab.kr/insight/interface-vs-abstract-class)
