
### Type Manipulation
---

- Type traits의 `type` 필드를 통해 어떤 타입을 다른 타입으로 조작할 수 있다.
- 템플릿 파라미터로 받은 타입을 알지 못해도 해당 타입의 포인터를 제거하거나 `const`를 붙이거나 제거하는 등 타입에 변형을 줄 때 사용할 수 있다.

- 아래와 같이 int형을 unsigned 형으로 바꿀 수 있다.
- C++14 --> `make_unsigned<int>::type == make_unsigned_t<T>`

```cpp
#include <type_traits>

using U = typename std::make_unsigned<int>::type;
// using U = typename std::make_unsigned<float>::type; // 부동소수점형이라 인자 불가
U y = 5;
```

```cpp
// signed, unsigned 조작
make_signed // signed 타입으로 조작
make_unsigned // unsigned 타입으로 조작

// 포인터와 레퍼런스 조작
remove_pointer // 포인터를 제거(T* -> T)
remove_reference // 참조를 제거(T& -> T)
add_pointer // 포인터로 변경(T -> T*)
add_reference // 참조로 변경(T -> T&)

// const 조작
remove_const // const 제거(const T -> T)
add_const // const로 변경

// 이외의 타입 조작
common_type<T, R> // T와 R의 공통인 타입을 반환. ex. <int, short> --> int
conditional<pred, T, R> // pred 식이 true이면 T, false이면 R을 반환
decay<T> // 함수 인자에 값으로 전달될 때와 같은 타입을 리턴한다.
```

- 예시
```cpp
template<typename T>
void f(T ptr) {
	using R = remove_pointer_t<T>;
	R x = ptr[0];
	cout << x;
}

template<typename T>
void g(T x) {
	using R = add_const_t<T>;
	R y = 3;
	// y = 4; // 변경할 수 없음
}

template<typename T, typename R>
common_type_t<T, R> add(T x, R y) {
	return x + y;
}

template<typename T, typename R>
auto h(T a, R b) {
	constexpr bool pred = sizeof(T) > sizeof(R);
	using S = std::conditional_t<pred, T, R>;
	return static_cast<S>(a) + static_cast<S>(b);
}

int main()
{
	auto x = h(2, 'a');
	cout << x << ": " << typeid(x).name() << "\n"; // print "99: int"
	auto y = h(2, 2ull);
	cout << y << ": " << typeid(y).name() << "\n"; // print "4 : unsigned __int64" 즉 unsigned long long
	auto z = h(2.0f, 2ull); 
	cout << z << ": " << typeid(z).name() << "\n"; // print "4 : unsigned __int64" 즉 unsigned long long
	
	char a[] = "abc";
	f(a); // print 'a'
	g(2);
	
	using res_t = decltype(add(2, 3.0f));
	res_t b = add(2, 3.0f);
	cout << b << ": " << typeid(b).name(); // print "5: float"
}
```
