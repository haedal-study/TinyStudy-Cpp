
### `static_assert`
---

- `static_assert` 키워드는 표현식을 컴파일 타임에 테스트하고 컴파일 오류를 발생시켜주는 기능을 한다. 
- 컴파일 타임에 결정되는 토큰들을 평가하는데 사용될 수 있다.(ex. `sizeof`, 리터럴, 템플릿, `constexpr`)
```cpp
// C++11
// static_assert(표현식, 오류 메시지)
static_assert(2+2==4, "test1");
static_assert(2+2==5, "test2"); // 컴파일 에러

// C++17. 에러 메시지 없이 사용
template<typename T, typename R>
void f() {static_assert(sizeof(T) == sizeof(R));}

f<int, unsigned>(); // 가능
// f<int, char>(); // 컴파일 에러

// C++26. text formatting
static_assert(sizeof(T) != 4, std::format("sizeof(T) = {}", sizeof(T)));
```

### `using`
---

- `using` 키워드를 사용해 별칭을 선언하고 별칭 템플릿을 만들 수 있다.

- `using`은 `typedef`와 달리 템플릿을 사용할 수 있다.
- 복잡한 템플릿 표현식을 간결하게 하는데 도움이 된다. 
- 템플릿의 부분/전체 특수화에 대한 별칭을 만들 수 있다.

```cpp
template<typename T, int Size>
struct Vector {}; // 클래스 템플릿(다음 장)

template<int Size>
using Bitset = Vector<bool, Size>; // 부분특수화에 대한 별칭 : Bitset

using IntV4 = Vector<int, 4>; // 전체 특수화에 대한 별칭 : IntV4

struct A {
	using type = int;
};
using Alias = A::type;

Alias a = 10;
// type b = 10; // compile error
```


### `decltype`
---

- `decltype`은 인자로 받은 값이나 표현식의 타입을 캡쳐해 컴파일 타임에 해당 타입으로 바뀌는(평가되는) 기능을 가진 키워드이다.
- `decltype`은 함수처럼 실행되는 것이 아니라, *평가*된다.

```cpp
int x = 3;
int& y = x;
const int z = 4;
int arr[2];
void f(int, float);

int main() {
	decltype(x) d1;       // int
	decltype(2 + 3.0) d2; // double
	decltype(y) d3 = x;   // int&
	decltype(z) d4 = z;   // const int
	decltype(arr) d5;     // int[2]
	// decltype(f(1, 2.0f)) d6; // error : C++20. void는 허용되지 않음.
}
```

- `decltype((표현식))` 처럼, `()`를 하나 더 넣어서 사용하면 다른 의미를 갖게 된다.
```cpp
bool f(int) { return true; }
struct A {
	int x;
};
int x = 3;
const A a{ 4 };

int main() {
	decltype(x) d1;         // int
	decltype((x)) d2 = x;   // int&
	decltype(f) d3;         // bool (int)
	decltype((f)) d4 = f;   // bool (&)(int)
	decltype(a.x) d5;       // int
	decltype((a.x)) d6 = x; // const int&
}
```

- `decltype`을 함수 템플릿에 사용하기 --> C++14부터는 `auto`가 더 가독성있다.
```cpp
template<typename T, typename R>
decltype(T{} + R{}) add(T x, R y) {
	return x + y;
}
unsigned v1 = add(1, 2u);
double v2 = add(1.5, 2u);

// C++14
template<typename T, typename R>
auto add(T x, R y) {
	return x + y;
}
```
