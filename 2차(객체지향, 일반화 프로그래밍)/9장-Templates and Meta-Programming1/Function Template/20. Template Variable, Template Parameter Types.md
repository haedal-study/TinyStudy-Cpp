
### Template Variable
---

- C++14부터 템플릿 변수를 만들 수 있다.(템플릿 변수는 템플릿 클래스에서 좀 더 중요하게 다뤄진다.)
```cpp
template<typename T>
constexpr T pi{3.1415926535897932385};

template<typename T>
T circular_area(T r){
	return pi<T> * r * r;
}

circular_area(3.3);  // double
circular_area(3.3f); // float
// circular_area(3); // compile error : int (narraowing conversion)
```


- 축소 변환(narrowing conversion) : 변환될 타입이 변환할 타입의 데이터를 온전히 받지 못하고 누락될 가능성이 있는 변환을 의미한다.(ex. `float` --> `int`)
	- 암시적 축소 변환의 경우 컴파일러 경고를 발생.
	- `static_cast`를 통해 명시적으로 형변환하자.
	- list-initialization의 경우 암시적 형변환을 허용하지 않기 때문에 컴파일러 오류 발생.


### Template Parameter Types
---

- 다음의 유형들이 템플릿 파라미터가 될 수 있다.

1. 정수형 타입
2. `enum`, `enum class`
3. 부동소수점형 (C++20)
4. `auto`(C++17)
5. 클래스 리터럴과 컨셉(class literal and concepts. C++20)
6. 일반화 타입(`typename`)

- 다음의 유형들도 드물게 쓰인다.
1. 함수
2. 전역 `static` 함수나 객체의 참조/포인터
3. 멤버 타입에 대한 포인터
4. `nullptr`(C++14)

#### 다중 값들(Multiple value)과 부동소수점형 타입(C++20)

```cpp
template <float T> // 부동소수점 타입의 template parameter
void print_float() {}

template <typename T> // 다중 값 타입의 template parameter
void print() {
	cout << T::x << "," << T::y;
}

struct Multi
{
	static const int x = 1;
	static constexpr float y = 2.0f;
};

print<Multi>(); // print "1,2"
```

#### `auto` 자리 표시자 타입(C++17)

- `auto` 키워드가 붙은 타입이 아닌 템플릿 파라미터(NTTP)를 사용하여 타입을 자동으로 추론하게 할 수 있다.
```cpp
template<typename T1, T1 X, typename T2, T2 Y>
void g1() {} // C++17 이전 방법

template<auto X, auto Y>
void g2() {}

g1<int, 1, char, 'a'>();
g2<1, 'a'>();
```

#### 클래스 탬플릿 파라미터 타입(C++20)

- 클래스 리터럴(Class Literal) 타입을 타입이 아닌 템플릿 파라미터(NTTP)로 사용할 수 있다.
	- 클래스 리터럴이란 `constexpr` 변수에 할당할 수 있는 클래스를 의미한다.
	- 클래스 리터럴의 기본 클래스와 비정적 멤버 변수들은 `public`이고 수정 불가(non-mutable)해야 함.
	- 클래스 리터럴의 기본 클래스와 비정적 데이터 멤버는 동일한 속성을 가져야 한다.

```cpp
struct A {
	int x;
	constexpr A(int x1) : x(x1) {}
};

template<A a>
void f() { cout << a.x; }

template<std::array arr>
void g() { cout << arr[2]; }

constexpr A a{ 1 }; // constexpr 키워드를 제거하면 error 발생
// a.x = 2; 수정 불가
f<a>(); // print 1
g<std::array{ 1,2,3 }>(); // print 3
```

#### 배열과 포인터 타입

```cpp
template<int* ptr> // 포인터
void g() {
	cout << ptr[0];
}
template<int(&arr)[3]> // 참조
void f() {
	cout << arr[0];
}
int array[] = { 2, 3, 4 }; // global

struct A {
	int x = 5;
	int y[3] = { 4, 2, 3 };
};

template<int A::* x> // 멤버 타입에 대한 포인터
void h1() {}

template<int(A::* y)[3]>
void h2() {}

int main() {
	h1<&A::x>();
	h2<&A::y>();
}
```

#### 함수 타입

```cpp
template<int (*F)(int, int)> // 함수 포인터
int apply1(int a, int b) {
	return F(a, b);
}

int f(int a, int b) { return a + b; }
int g(int a, int b) { return a * b; }

template<decltype(f) F> // decltype()에 넣은 식의 타입으로 치환됨.
int apply2(int a, int b) {
	return F(a, b);
}

int main()
{
	apply1<f>(2, 3); // return 5
	apply2<g>(2, 3); // return 6
}
```