
### Default Value
---

- 템플릿도 기본값을 가질 수 있다.
```cpp
template<typename T = int>
void f()
{
	cout << typeid(T).name();
}

template<int A = 3, int B = 4>
void print1() { cout << A << ", " << B; }

template<int A = 3, int B> // 가능은 하지만 A에 기본값을 주는게 의미가 없음.
void print2() { cout << A << ", " << B; }

f(); // 'int'
f<float>(); // 'float'

print1(); // print `3, 4`
print1<2>(); // print '2, 4'
print1<1, 2>(); // print '1, 2'

print2<2, 5>(); // print '2, 5'
// print2<2>(); // error
// print2(); // error
```

- 템플릿 파라미터의 이름이 없을 수도 있다. `void`
- 이런 경우의 템플릿 함수는 함수가 사용되는 경우에만 최종 코드를 생성한다.
```cpp
void f() {} // 일반 함수의 경우, 항상 코드가 생성됨.

template<typename = void>
void g() {}

int main() {
	g(); // generated
}
```

- 템플릿 파라미터는 앞서 선언된 템플릿 파라미터를 사용해 초기화 할 수도 있다.
```cpp
template<int A, int B = A + 3>
void f() {
	cout << B;
}
template<typename T, int S = sizeof(T)>
void g(T) {
	cout << S;
}

f<3>(); // B = 6
g(3); // S = 4
```


### Function Template Overloading
---

- 템플릿 함수도 오버로딩이 가능하다. 또한 `template`도 시그니처의 한 부분으로써 오버로딩을 할 수 있다.
```cpp
template<typename T>
T add(T a, T b) {
	return a + b;
}

template<typename T>
T add(T a, T b, T c) {
	return a + b + c;
}

template<int C, typename T>
T add(T a, T b) {
	return a + b + C;
}
```


### Template Specialization
---

- 템플릿 특수화(template specialization)은 특정한 조합의 템플릿(혹은 특정 타입) 파라미터에 대한 구현을 따로 만들어놓는 기능이다. (오버로딩 비슷)

- 부동 소수점 반올림 오류(floating-point rounding error) 같이 부동소수점 타입을 사용할 때에 발생할 수 있는 문제점을 방지할 수 있다.

```cpp
template<typename T>
T comp(T a, T b) {
	return a == b;
}

template<>
float comp(float a, float b) {
	return std::abs(a - b) < 1e-9;
}

cout << comp<int>(1, 1); // "true"
cout << comp<float>(10.0000001f, 10.0f); // "true"
```

