
### Template Instantiation
---

- 템플릿 인스턴스화(template instantiation)는 템플릿 매개 변수를 구체적인 값(혹은 타입. concrete type)으로 대체하는 것이다.

- 컴파일러는 각 템플릿 인스턴스에 맞는 함수를 각각 생성한다. 템플릿이 실제 코드로 변환되는 것이다.
```cpp
template<typename T>
T add(T a, T b) {
	return a + b;
}

add(3, 4); // int형 함수 구현 생성. int add(int, int)
add(3.0f, 4.0f); // float형 함수 구현 생성. float add(float, float)
add(2, 6); // already generated
```

- 템플릿 인스턴스화는 암시적/명시적으로 일어난다.

- 암시적 템플릿 인스턴스화
	- 추론한 함수 인자의 타입이나 명시적 템플릿 인자에 따른 코드를 생성한다.
	- 오직 함수의 정의를 사용할 때에만 생성함.

- 명시적 템플릿 인스턴스화
	- 함수 선언으로 정해준 명시적 템플릿 인자에 따른 코드를 생성한다. 
	- 특정 타입에 대한 템플릿 인스턴스를 미리 생성하여 컴파일 시간을 줄이고 코드 크기를 최적화할 수 있다.
	- 다중 번역 단위에서 바이너리 크기를 줄일 때 사용할 수 있다. 
		- 헤더에 템플릿 함수를 선언하고 소스파일에 함수를 정의할 때, 소스파일에 명시적 템플릿 인스턴스화를 함께 적는다. (참고자료)

```cpp
template<typename T>
void f(T a) {}

void g() {
	f(3); // void f(int) 생성 : 암시적 템플릿 인스턴스화
	f<short>(3.0); // void f(short) 생성 : 암시적 템플릿 인스턴스화
}

template void f<int>(int); // void f(int) 생성 : 명시적 템플릿 인스턴스화
```
### Template Parameters
---

- 템플릿 파라미터(Template Parameter)는 `template` 키워드 뒤에 따라오는 일반화 타입의 이름이다. 
- 함수의 파라미터가 인자를 받듯이 템플릿 파라미터는 타입을 인자로 받을 수 있다.

```cpp
template<typename T> // typename T : template parameter(템플릿 파라미터)
void f() {}
f<int>(); // int : template argument(템플릿 인자)
```

- **템플릿 파라미터**는 일반화 타입(`typename T`) 뿐만 아니라 타입이 아닌 템플릿 파라미터(non-type template parameters : NTTP)일 수도 있다.
- 일반화 타입의 **템플릿 인자**는 빌트인 타입이나 사용자 정의 자료형, NTTP인 구체적인 값을 의미한다.

- NTTP를 받는 템플릿 함수 예시
```cpp
// int (NTTP)를 템플릿 파라미터로
template<int A, int B>
int add_int() {
	return A + B; // 컴파일 타임에 계산할 수 있음!
}
// enum (NTTP)를 템플릿 파라미터로
enum class Enum { Left, Right };
template<Enum Z>
int add_enum(int a, int b) {
	return (Z == Enum::Left) ? a + b : a;
}

int a = add_int<10, 20>(); // 30
int b = add_enum<Enum::Left>(1, 2); // 3
```


참고자료

https://pretending.tistory.com/entry/C-Template-Instantiation-%ED%85%9C%EB%B8%94%EB%A6%BF-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94
