
### Class Template
---

- 클래스 템플릿(Class Template)은 여러 타입을 지원하는 클래스를 만드는데 사용된다.

- 부분 특수화와 전체 특수화
	- 부분 특수화(Partial Specialization) : 템플릿 파라미터를 일부만 특수화하는 것
	- 전체 특수화(Full Specialization) : 템플릿 파라미터를 전부 특수화하는 것

- 주의
	- 클래스 템플릿의 어떤 특수화든, 특수화한 클래스와 원래 클래스와의 공유되는 부분은 전혀 없다. 이름만 같은 다른 클래스인 것이다.

```cpp
template<typename T, typename R>
struct A {
	T a;
	R b;
	void foo() { cout << "Generic class" << "\n"; }
};

template<typename T> // 부분 특수화
struct A<T, int> {
	T a1;
	int b1;
	void foo() { cout << "Partial" << "\n"; }
};

template<> // 전체 특수화
struct A<int, float> {
	int a2;
	float b2;
	void foo() { cout << "Full" << "\n"; }
};

A<int, char> a;
a.foo(); // print "Generic class"
A<double, int> a1;
a1.foo(); // print "Partial"
A<int, float> a2;
a2.foo(); // print "Full"
```


#### 클래스 템플릿을 사용한 꿀기능 구현

- 클래스 템플릿의 특수화를 사용해 Type Traits의 일부 기능을 간단히 구현할 수 있다.
- `static` 멤버 변수를 사용해 객체 생성에 따른 비용을 아낄 수 있다.

1. 부분 특수화를 사용해 두 타입이 같은지 검사
```cpp
template<typename T, typename R>
struct Is_same{
	static constexpr bool value = false;
};

template<typename T> // 부분 특수화
struct Is_same<T, T> { // 같은 타입을 대입했을 때 적용되는 클래스 템플릿
	static constexpr bool value = true;
};

cout << Is_same<int, char>::value << "\n"; // false
cout << Is_same<bool, bool>::value << "\n";// true
```

2. 부분 특수화를 사용해 포인터가 `const`인지 검사
```cpp
template<typename T>
struct Is_const_ptr{
	static constexpr bool value = false;
};

template<typename T> // 부분 특수화
struct Is_const_ptr<const T*> { // const 포인터 타입의 인자가 들어오면 적용
	static constexpr bool value = true;
};

cout << Is_const_ptr<const int>::value << "\n"; // false
cout << Is_const_ptr<const char*>::value << "\n"; // true
```

3. 부분 특수화를 사용해 두 클래스 템플릿이 같은 클래스인지 검사
	1. `std::false_type`, `std::true_type` : 클래스의 특정 타입이 특정 조건을 만족하면 컴파일타임에 참/거짓 값을 갖도록 `value`를 제공하는 클래스. 해당 클래스를 상속받음으로써 사용할 수 있다.
```cpp
template<typename T>
struct A {};

template<typename T, typename R>
struct Compare : std::false_type {};

template<typename T, typename R>
struct Compare<A<T>, A<R>> : std::true_type {}; // 부분 특수화
// 위와 같이 부분특수화한 타입의 경우에는 true의 value를 갖도록 지정할 수 있음

cout << Compare<int, float>::value; // false
cout << Compare<A<int>, A<int>>::value; // true
cout << Compare<A<int>, A<float>>::value; // true
```

