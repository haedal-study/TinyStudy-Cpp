
### Template Meta-Programming
---

- 메타 프로그래밍(Meta-Programming)이란 자기 자신 혹은 다른 프로그램을 데이터로 취급하여 프로그램을 읽고, 생성하고 변경하는 등의 작업을 말한다.
- 템플릿 메타 프로그래밍은 템플릿을 사용해 컴파일 시간에 작업을 끝내는 것을 말한다.
	- 컴파일 타임 상수, 데이터 구조, 전체 함수가 포함된다.

- 장점
	- 많은 작업들을 컴파일 타임에 해결하기 때문에 런타임에 빠르다.
	- 모든 프로그래밍 언어들이 해결할 수 있는 작업들을 해낼 수 있다. --> 튜링 완전
- 단점
	- 재귀적인 템플릿으로 인해 컴파일 타임 시간이 길어지고, 일반 프로그램 코드보다 메모리를 많이 사용하게 된다.
	- 프로그램 코드가 복잡해 읽고 쓰기 어려우며, 디버그도 어렵다.

- 재귀적인 탬플릿의 예시
```cpp
template<int N> // 템플릿 재귀
struct Factorial {
	static constexpr int value = N * Factorial<N - 1>::value;
};

template<> 
struct Factorial<1> {
	static constexpr int value = 1;
};

constexpr int x = Factorial<5>::value; // 120
// int y = Factorial<-1>::value; // 런타임에 무한 재귀
```

- 위 팩토리얼 예시를 아래와 같이 보다 효율적으로 바꿀 수 있다.(C++14)
```cpp
template<typename T>
constexpr int factorial(T value) {
	T tmp = 1;
	for (int i = 2; i <= value; i++)
		tmp *= i;
	return tmp;
};

constexpr int x = factorial<int>(5); // 120
```
- 재귀적으로 탬플릿이 사용되지 않아 컴파일이 더 빠름
- 가독성 있음
- 여러 타입들에 대해 똑같이 사용 가능
- 런타임과 컴파일 타임에 사용 가능


- 템플릿을 재귀적으로 사용해 Log 구현하기
```cpp
template<int A, int B>
struct Max { // utility
	static constexpr int value = A > B ? A : B;
};

template<int N, int BASE>
struct Log { // 재귀로 로그의 값을 구함
	static_assert(N > 0, "N must be greater than zero");
	static_assert(BASE > 0, "BASE must be greater than zero");
	// Log<0, BASE>을 막기 위해 Max로 항상 0 이상의 값만 갖도록 함
	static constexpr int TMP = Max<1, N / BASE>::value;
	static constexpr int value = 1 + Log<TMP, BASE>::value;
};

template<int BASE>
struct Log<1, BASE> {
	static constexpr int value = 0;
};


constexpr int x = Log<20, 2>::value; // 4
```

- Unroll 구현하기. (0부터 N-1까지의 수를 출력)
```cpp
template<int NUM_UNROLL, int STEP = 0>
struct Unroll {
	template<typename Op>
	static void run(Op op) {
		op(STEP);
		Unroll<NUM_UNROLL, STEP + 1>::run(op);
	}
};

template<int NUM_UNROLL>
struct Unroll<NUM_UNROLL, NUM_UNROLL> { // 부분 특수화 : 마지막으로 호출될 템플릿
	template<typename Op>
	static void run(Op) {}
};



int main() {
	auto lambda = [](int step) { cout << step << ", "; };
	Unroll<5>::run(lambda); // print "0, 1, 2, 3, 4," 
	// Unroll<5, 0>::run --> Unroll<5, 1>::run --> Unroll<5, 2>::run
	// --> Unroll<5, 3>::run --> Unroll<5, 4>::run --> Unroll<5, 5>::run
}
```

