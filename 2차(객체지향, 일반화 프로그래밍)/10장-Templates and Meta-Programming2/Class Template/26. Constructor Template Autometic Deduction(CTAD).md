
### 클래스 템플릿의 생성자
---

- 클래스 템플릿의 생성자는 템플릿 인자를 사용해 새로 구현하지 않아도, 기존 생성자로 사용해도 충분하다.
```cpp
template<typename T>
struct A {
	A() {} // A<T>() 와 같다.
	A(const A& x); // A(const A<T>&) 와 같다.

	A f();
	void g(){ // A<T> f(); 와 같다.
		cout << is_integral_v<T> << "\n"; 
	}
};

A<int> a;
a.g(); // true
```


### Constructor Template Autometic Deduction(CTAD)
---

- C++17부터는 템플릿 클래스의 생성자로 받은 인자의 타입을 자동으로 추론해 객체를 생성한다.
- 이를 사용자가 직접 추론 가이드(Deduction Guide)를 제공할 수도 있다.
```cpp
template<typename T, typename R>
struct A {
	A(T x, R y) {}
};

A<int, float> a1(3, 4.0f); // C++17
A a2(3, 4.0f); // C++17
// A<int> a{3, 5}; error. 부분특수화가 안 되어있음.
```

- 사용자 가이드
```cpp
template<typename T>
struct A {
	A(T x) { cout << x; }
};

// 생성자 -> 클래스 초기화
A(char const*) -> A<string>; // 사용자 가이드

A a("haha"); // print "haha"
```

- 독립 인자(Independent Argument) 예시
```cpp
template<int I>
struct A {
	template<typename T>
	A(T) {}
	void f() { cout << I; }
};

template<typename T>
A(T) -> A<sizeof(T)>;

A a{ 1.2 };
// 1. 생성자의 인자 T = double
// 2. 사용자 가이드에 의해 A<double> -> A<sizeof(double)>로 변환
// 3. A의 템플릿 파라미터 I가 sizof(double) == 8로 치환
a.f(); // print '8'
```

- 별칭 템플릿 추론(Alias template deduction)
```cpp
template<typename T>
struct A {
	A(T) {}
};
template<typename T>
A(T) -> A<int>; // deduction guide

template<typename T>
using B = A<T>; // 별칭 템플릿

B c{ 3.0 }; // alias template deduction
// B => A<T> => A<int>
```


#### 사용자 정의 추론 가이드의 한계

- 클래스 내부에서는 사용자 정의 추론이 먹히지 않는다.
```cpp
template<typename T>
struct MyString {
	MyString(T) {}
	MyString f() { return MyString("abc"); } // MyString<const char*> 생성. string으로 바뀌지 않음.
};

MyString(const char*)->MyString<std::string>;

MyString<const char*> s{ "abc" }; // construct 'MyString<const char*>'
cout << typeid(s.f()).name(); // print "struct MyString<char const* __ptr64>"
```

- 객체를 외부에서 만들 수 있는 공장(factory) 함수를 정의해 사용하면 사용자 정의 추론 가이드가 적용된 객체가 생성된다.
```cpp
template<typename T>
auto make_my_string(const T& x) { return MyString(x); }

auto a = make_my_string("abc");
cout << typeid(a).name(); // string에 해당하는 타입 이름 출력..
```
