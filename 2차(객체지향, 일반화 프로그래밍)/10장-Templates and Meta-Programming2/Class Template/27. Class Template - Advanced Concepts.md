
### Class + Function Specialization
---

- 템플릿 함수가 들어있는 템플릿 클래스를 특수화하는 방법은 다음과 같다.

1. 제네릭 클래스 + 제네릭 함수 그대로 두는 것
2. 전체 특수화 클래스 + 제네릭/전체 특수화 함수

- 클래스와 함수 모두 **부분 특수화를 사용할 수 없다!**
- 클래스가 전체 특수화 되지 않으면 함수도 전체 특수화 될 수 없다!

```cpp
template<typename T, typename R>
struct A {
	template<typename X, typename Y>
	void foo() {}
};

// 방법 1 : 제네릭 클래스 + 제네릭 함수
template<typename T, typename R>
template<typename X, typename Y>
void A<T, R>::foo() {}

// 방법 2 : 클래스 전체 특수화 + 제네릭/전체 특수화 함수
template<>	// 클래스 A<int,int>로 전체 특수화
template<typename X, typename Y> // 함수는 특수화하지 않음
void A<int, int>::foo() {};

template<> // 클래스 A<int,int>로 전체 특수화
template<> // 함수 foo<char,char>로 전체 특수화
void A<int, int>::foo<char, char>() {};
```


### Accessing a Dependent Type - `typename`
---

- 24장(Type Manipulation)에서 type manimpuation을 수행할 때, 아래와 같이 앞에 `typename`을 붙였다. 왜 붙였을까?
```cpp
using U = typename std::make_unique<T>::type;
```

- 구조체 템플릿은 각 특수화마다 서로 다른 데이터들을 가지고 있다.
- 따라서 다른 템플릿 인자(`R`)에 의존하는 구조체 템플릿(`A`)이 가진 데이터(`type`)가 "타입"일지 "정적 변수"일지 특수화마다 달라질 수 있기 때문에 해당 데이터가 타입임을 컴파일러에 명시하기 위해 `typename` 키워드를 사용하는 것이다.

```cpp
template<typename T>
struct A {
	using type = int;
};

template<> // 정적 데이터를 가진 특수화한 구조체
struct A<int> {
	static int type;
};

template<typename R>
void g() {
	using X = typename A<R>::type; // 템플릿 인자 R에 의존하는 구조체 A
	// type이 타입인지 정적 변수인지 명확히 하기 위해 typename을 사용
}

// g<int>(); // error
g<float>();
```

- `using` 키워드를 사용해 타입을 좀 더 간편하게 가져올 수 있다.
```cpp
template<typename T>
struct A{
	using type = int;
};

template<typename T>
using Atype = typename A<T>::type;

template<typename R>
void g(){
	using X = AType<R>; // 와! 간편하다?!
}
```


### Template Dependent Names - `template`
---

- `template` 키워드는 뒤따라오는 키워드가 일반 함수나 타입이 아닌 템플릿 함수/클래스 혹은 타입임을 명시해준다. 이는 종속 이름이 가지는 모호함을 해소해 줄 때 사용될 수도 있다.

- 종속 이름(dependent name) : 템플릿 파라미터에 따라 달라지는 식별자.
	- 템플릿 파라미터가 달라짐에 따라 참조하는 데이터가 달라질 수 있기 때문에 모호하다.
	- `T::f`가 정적 데이터 멤버일 수도 있고, T의 타입 멤버일 수도 있다.

- 아래와 같이 `container.template add<int>(42);`에 `template`이 없다면, `add<int>`가 종속 이름이기 때문에 모호하다.
```cpp
template <typename T>
struct Container {
    template <typename U>
    void add(U value);
};

template <typename T>
struct Wrapper {
    void call() {
        Container<T> container;
        container.template add<int>(42); // `add` is a dependent template
    }
};
```

### Class template 상속과 `using`
---

- 템플릿 멤버를 가진 클래스를 상속받은 자식 클래스는 부모의 템플릿 멤버를 사용하기 위해 다음과 같이 나타내주어야 한다.
- `using`을 사용해 "이 멤버가 어떤 타입 부모 클래스의 멤버입니다." 를 나타낸다.
```cpp
template<typename T>
struct A {
	T x;
	void f() { cout << "A::f()" << "\n"; }
};

template<typename T>
struct B : A<T> {
	using A<T>::x; // needed (만약 없으면, 다른 특수화가 될 수도 있음)
	using A<T>::f; // needed 

	void g() {
		x = 10; // without 'using': this->x
		f();
		cout << "x : " << x << "\n";
		cout << "B::g()" << "\n";
	}
};

int main() {
	B<int> b;
	b.g(); // "A::f()
           // x: 10
           // B::g()"
}
```


### `virtual` 함수와 템플릿
---

- 가상 함수는 템플릿을 사용해 작성될 수 없다.
- 템플릿은 컴파일 시간에 동작하는 기능이고, 가상 함수는 런타임에 동작하는 기능이기 때문이다.


### `friend` 키워드와 템플릿
---

- `friend` 키워드를 붙여 특정 템플릿 인자를 받는 템플릿 함수/클래스를 친구로 만들 수 있다.

```cpp
template<typename T> struct A {};
template<typename T, typename R> struct B {};
template<typename T> void f(class C c);

class C {
	int x = 2;

	friend void f<int>(C c); // 오직 f<int> 함수와 친구

	template<typename T> friend void f(C c); // 모든 f 함수와 친구

	friend struct A<int>; // 오직 A<int> 클래스과 친구

	template<typename> friend struct A; // 모든 A 클래스과 친구

	// template<typename T> friend struct B<int, T>;
	// friend 키워드를 사용하면, 부분특수화는 불가능하다.
};

template<typename T>
void f(C c) { cout << c.x; }

C c;
f<int>(c);
// f<char>(c); // template<typename T> friend void f(C c);를 지우면 error
```


### Template Template Argument
---

- 템플릿 템플릿 인자는 구체적인 타입 대신 템플릿을 전달한다.
- C++17부터 `class`와 `typename`은 똑같은 의미로 사용된다(상호대체가능).
```cpp
template<typename T> struct A {
	T a;
	A(T _a) :a(_a) {}
};

template< template<typename> class R >
struct B {
	R<int> x;
	R<float> y;
	B() :x(1), y(2.2f) {}
	void f() {
		cout << x.a << ", " << y.a;
	}
};

template< template<typename> class R, typename S >
void f(R<S> x) {}

int main()
{
	// 순서
	// 1. B 템플릿 인자에 A<T>가 들어감.
	// 2. R. 즉 A<T>가 각각 A<int> x, A<float> y 가 됨.
	// B의 생성자에서 각각 값이 할당.
	B<A> y;
	y.f(); // print "1, 2.2"
	f(A<int>(1));
}
```

