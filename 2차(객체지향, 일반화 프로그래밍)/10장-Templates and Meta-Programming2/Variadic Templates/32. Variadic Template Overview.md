
### Variadic Template(C++11)
---

- **가변 템플릿(Variadic Template)** 은 임의의 수의 인자나 타입을 받는 파라미터 팩(parameter pack)을 가진 템플릿을 의미한다.
- **파라미터 팩** 은 `typename`뒤에 식별자 `...TArgs`로 표시되는 부분이다. 캡쳐된 파라미터 팩은 다음에 `...`키워드를 통해 **펼쳐진(expanded)** 패턴으로 사용할 수 있다.(ex. 아래 예시의 함수 인자)
```cpp
template<typename... TArgs> // 파라미터 팩 : ...TArgs
void f(TArgs... args){} // 팩 펼치기 -> 패턴 : TArgs
```

- **팩 펼치기(pack expansion)** 는 패턴의 쉼표로 구분된 인스턴스 목록과 동일하다. 팩 **뒤에** `...` 키워드를 붙임으로써 팩에 들어있는 타입/값들을 꺼내올 수 있다.
- **패턴(pattern)** 은 하나 이상의 파라미터 팩의 식별자를 포함하는 **토큰 집합** (예시2참조)이다. 만약 패턴이 두 개 이상의 파라미터 팩을 가질 경우, 그 팩들의 길이는 같아야 한다.
```cpp
template<typename... TArgs> // parameter pack
void f(TArgs... args) { // Typename expansion(typename 펼치기)
	int values[] = { args... }; // Arguments expansion(인자(값) 펼치기)
}

f(1,2,3); // <- f<int,int,int>(int args, int args, int args);
```

#### 가변인자 사용
- 가변 인자의 크기를 알려면 `sizeof()...` 연산자를 사용하면 된다.
- 가변 인자는 항상 선언의 맨 마지막에 와야 한다!
```cpp
template<typename... TArgs>
void f(TArgs... args) {
	cout << sizeof...(args);
}

f(1, 2, 3); // print '3'
```


#### 예시

- 예시 1
```cpp
// BASE CASE
template<typename T, typename R>
auto add(T a, R b) {
	return a + b;
}

template<typename T, typename... TArgs> // 가변인자 typename
auto add(T a, TArgs... args) { // typename 펼치기
	return a + add(args...); // 인자 펼치기. 재귀호출로 가변 인자들을 전달
}

int main()
{
	add(2, 3.0); // 5
	add(2, 3.0, 4); // 9
	add(2, 3.0, 4, 5); // 14
	// add(2); // compile error : base case에 하나의 인자 밖에 안 들어감.
}
```
- 위의 예시에서 BASE CASE `add`함수를 가변인자를 받는 `add`함수 밑에 선언하면 오류가 발생한다. 재귀호출을 하며 마지막에 BASE CASE를 찾을 때, 본인보다 밑에 있어 찾지 못해 오류가 발생한다.

- 예시 2
```cpp
// 위 예시의 add 함수들을 사용한다고 가정한다.

struct A {
	int v;
	int f() { return v; }
};

template<typename... TArgs>
int f(TArgs... args) {
	return add(args.f()...); // 'A{1}.f(), A{2}.f(), A{3}.f()' 과 동일
}


int main()
{
	cout << f(A{ 1 }, A{ 2 }, A{ 3 }); // print 6
}
```
- Pack expension은 파라미터 팩에만 사용할 수 있는 것이 아니라, 팩을 사용하는 패턴에 `...`을 통해 사용될 수 있다. 위의 `args.f()...`가 그것이다.

- 예시3
```cpp
// 예시1의 add 함수를 사용한다고 가정한다.

template<typename T>
T square(T value) { return value * value; }

template<typename... TArgs>
auto add_square(TArgs... args) {
	return add(square(args)...); // square()가 각 가변 인자마다 적용
}

int main()
{
	cout << add_square(2, 2, 3.0f); // print 17
}
```


- 예시4
- 인자 전달 방식에 따라 다음과 같이 나타낼 수 있다.
```cpp
template<typename... TArgs>
void f(TArgs... args) {} // 값 전달

template<typename... TArgs>
void g(const TArgs&... args) {} // const 참조 전달

template<typename... TArgs>
void h(TArgs*... args) {} // 포인터 전달

template<int... Sizes>
void l(int(&...arrays)[Sizes]) {} // 배열 참조 전달


int main()
{
	int a[] = { 1, 2 };
	int b[] = { 1, 2, 3 };
	f(1, 2.0);
	h(a, b);
	l(a, b); // g()와 동일
}
```


### 참고
---

- 파라미터 팩으로 같은 타입의 가변 인자들을 받을 수도 있다. (타입은 하나만. 인자 개수는 가변)
```cpp
template<int... Ints>
void f(Ints... ints){} // 반드시 int만을 인자로 주어야 함.
```

- 람다 식에서도 가변 인자를 사용할 수 있다.

- 람다의 캡쳐 리스트, 생성자의 초기화 리스트, `using` 선언에서도 사용 가능하다.

```cpp
template<typename... BaseClasses>
struct A : BaseClasses... { // : BaseClass_1, BaseClass_2, ...
	A(int v) : BaseClasses...{v} {} // BaseClass_1{v}, BaseClass_2{v}, ...
	
	using BaseClasses::f; // 각 BaseClasses의 f를 사용하도록 함.
	// equivalent to:
	// using BaseClass_1::f;
	// using BaseClass_2::f;
	// ...
};

// C++20부터 가능
void f(auto... args) {
	auto lambda = [arg&...]() {}; // [capture list]
}
```

참고자료

[씹어먹는 C++ - <9 - 2. 가변 길이 템플릿 (Variadic template)> (modoocode.com)](https://modoocode.com/290)
[C++ Template Programming - Variadic Template : 네이버 블로그 (naver.com)](https://m.blog.naver.com/hikari1224/221505436876)
