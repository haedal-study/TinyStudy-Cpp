
### Folding Expression
---

- C++17부터 Folding 표현을 사용할 수 있다.
- Folding이란 파라미터 팩에 이항 연산들을 적용시켜주는 기능이다.
(`+ - * / % ^ & | = < > << >> += = *= /= %= ^= &= |= <<= >>= == != <= >= && || , .* ->*`)

- 목적
	- 32일차의 `add` 함수와 같이 가변 인자들을 하나씩 연산할 때 재귀적으로 수행하고, 항상 Base Case가 필요했다.
	- 이를 Folding으로 간단하게 표현할 수 있게 되었다.
```cpp
// BASE CASE
template<typename T, typename R>
auto add(T a, R b) {
	return a + b;
}

template<typename T, typename... TArgs> // 가변인자 typename
auto add(T a, TArgs... args) { // typename 펼치기
	return a + add(args...); // 인자 펼치기. 재귀호출로 가변 인자들을 전달
}

//----------------------------------------------------------------------------
// Folding 표현으로 바꾸면..

template<typename... TArgs>
auto add(TArgs... args) {
	return (... + args);
}

cout << add(1, 2, 3, 4); // print 10
```

#### Folding 표현 종류 (E는 팩, I는 초기값)

| 이름              | Fold 방식    | 실제 전개 형태                                |
| --------------- | ---------- | --------------------------------------- |
| (E op ...)      | 단항 우측 Fold | (E1 op (E2 op(... (En-1 op En))))       |
| (... op E)      | 단항 좌측 Fold | (((E1​ op E2​) op ...) op En​)          |
| (E op ... op I) | 이항 우측 Fold | (E1​ op (... op (En−1​ op (En​ op I)))) |
| (I op ... op E) | 이항 좌측 Fold | ((((I op E1​) op E2​) op ...) op EN     |

#### 콤마(`,`) 사용

```cpp
template<typename... TArgs>
int f(TArgs... args) {
	return (args, ...); // 콤마 연산자에 의해 왼쪽 값이 벼려진다. (리턴 값에 콤마가 있으면 맨 오른쪽 값을 취함)
} // same as (..., args)

cout << f(1, 2, 3); // return 3
```
- 가변 인자들 중 마지막 인자를 꺼내올 수 있음


- 사용 예시
```cpp
template<typename T>
T square(T value) { return value * value; }

template<typename... TArgs>
auto add_square(TArgs... args) {
	return (square(args) + ...); // 각 가변 인자에 대해 square() 함수 적용
}
// 실제 -> (2*2 + (2*2 + 3.0*3.0))

add_square(2, 2, 3.0f); // returns 17.0f
```


### Variadic Class Template
---

- 가변 인자 템플릿 클래스를 다음과 같이 나타낼 수 있다.
```cpp
template<int... NArgs>
struct Add; // 구조체 선언

template<int N1, int N2>
struct Add<N1, N2> { // BASE case
	static constexpr int value = N1 + N2;
};

template<int N1, int... NArgs>
struct Add<N1, NArgs...> { // RECURSIVE case
	static constexpr int value = N1 + Add<NArgs...>::value;
};

cout << Add<2, 3, 4>::value; // print 9
```

- Folding 사용
```cpp
template<int... NArgs>
struct Add {
	static constexpr int value = (NArgs + ...);
};

cout << Add<2, 3, 4, 5>::value; // print 14
```

- 재귀적인 데이터 구조 구성하기
```cpp
template<typename... TArgs>
struct Tuple; // 구조체 선언

template<typename T>
struct Tuple<T> { // base case
	T value;
};

template<typename T, typename... TArgs>
struct Tuple<T, TArgs...> { // recursive case
	T value; // specialization with more
	Tuple<TArgs...> tail; // than one parameter
};

int main()
{
	Tuple<int, float, char> t1{ 2, 2.0, 'a' };
	cout << t1.value; // 2
	cout << t1.tail.value; // 2.0
	cout << t1.tail.tail.value; // 'a'
}
```

