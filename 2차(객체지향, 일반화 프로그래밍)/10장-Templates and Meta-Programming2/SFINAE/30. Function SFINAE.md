
#### SFINAE를 함수에서 활용해보자.

### Return Type
---

```cpp
#include <type_traits>

template<typename T>
enable_if_t<is_integral_v<T>> f(T) {
	cout << "integral";
}

f(1);  // print "integral"
//f(1.2); // compile error
```


### Parameter
---

```cpp
template<typename T>
void f(T, enable_if_t<is_signed_v<T>, int> = 0) {
	cout << "signed";
}
template<typename T>
void f(T, enable_if_t<!is_signed_v<T>, int> = 0) {
	cout << "unsigned";
}

// 아래와 같이 파라미터를 받으면 f(1)과 같은 호출은 시그니처가 맞지 않아 오류 발생
//template<typename T>
//void f(std::enable_if_t<std::is_signed_v<T>, T>) {
//	cout << "signed";
//}

int main()
{
	f(1);  // print "signed"
	f(1u); // print "unsigned"
}
```

#### Template Parameter

```cpp
// 숨겨진 템플릿 인자를 통해 enable_if 사용
template<typename T, enable_if_t<is_signed_v<T>, int> = 0>
	void f(T) {
	cout << "signed";
}

template<typename T, enable_if_t<!is_signed_v<T>, int> = 0>
	void f(T) {
	cout << "unsigned";
}

f(1);  // print "signed"
f(1u); // print "unsigned"
```


### Array와 Pointer
---

- 배열을 템플릿 인자로 받으려면 다음과 같이 선언하도록 하자.
- 그렇지 않으면 배열이 포인터로 붕괴된다.
```cpp
// 1 옳은 방법
template<typename T, int SIZE> 
void f(T(&arr)[SIZE]) {
	cout << "size of " << SIZE;
}

// 2
//template<typename T>
//void f(T* arr) {
//	cout << "ppttrr";
//}

// 3
template<typename T>
enable_if_t<is_pointer_v<T>> f(T ptr) {
	cout << "pointer";
}

int main()
{
	int arr[3];
	int* p = nullptr;
	f(arr); // print "size of 3"
	f(p); // print "pointer"
}
```

- 2번 함수를 사용했을 때, `f(arr)`는 포인터로 붕괴된다. 그리고 1번과 2번을 함께 사용하면 컴파일러가 어떤 함수를 사용할 지 결정하지 못해 에러가 발생한다.
- 1번과 3번을 함께 사용하면 배열과 포인터를 올바르게 받을 수 있다.


### `enable_if` 사용 시 주의사항
---

1.
```cpp
template<typename T, typename = std::enable_if_t<std::is_signed_v<T>>>
	void f(T) {}

// SFINAE의 잘못된 사용
//template<typename T, typename = std::enable_if_t<!std::is_signed_v<T>>>
//void f(T) {}
// compile error: 두번째 템플릿 파라미터를 재정의하여 발생
```

2.
```cpp
//template<typename T>
//std::enable_if_t<std::is_signed_v<T>, auto> f(T) {}
// compile error : enable_if_t을 리턴에 사용할 때, auto를 통한 추론이 막힌다.

template<typename T>
enable_if_t<is_signed_v<T>> f(T) {

}

// auto x = f(1); // auto 추론 불가
```
