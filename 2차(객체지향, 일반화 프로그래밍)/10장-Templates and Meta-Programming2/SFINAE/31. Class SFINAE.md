
- 클래스에서 SFINAE 사용
```cpp
template<typename T, typename Enable = void>
struct A;

template<typename T>
struct A<T, enable_if_t<is_signed_v<T>>> {
	void foo() { cout << "signed"; }
};

template<typename T>
struct A<T, enable_if_t<!is_signed_v<T>>> {
	void foo() { cout << "unsigned"; }
};

int main()
{
	A<int> a1;
	A<unsigned> a2;
	a1.foo(); // print "signed"
	a2.foo(); // print "unsigned"
}
```

- 클래스에서 SFINAE를 통해 클래스의 변수나 타입이 존재하는지 컴파일 시간에 확인할 수 있다.
```cpp
#include <type_traits>
#include <utility>

struct A {
	static int x;
	int y;
	using type = int;
};
struct B {};

// 변수가 존재하는지 확인하는 구조체들
template<typename T, typename = void>
struct has_x : std::false_type {};

template<typename T>
struct has_x<T, decltype((void)T::x)> : std::true_type {};

template<typename T, typename = void>
struct has_y : std::false_type {};

template<typename T>
struct has_y<T, decltype((void)std::declval<T>().y)> : std::true_type {};

// 타입이 존재하는지 확인하는 구조체들
template<typename T, typename = void>
struct has_type : std::false_type {};

template<typename T>
struct has_type<T, std::void_t<typename T::type> > : std::true_type {};

int main()
{
	cout << has_x<A>::value; // true
	// 과정.
	// 첫번째로 has_x<A, void(디폴트)>를 검사한다. --> 가능
	// 특수화가 있는지 찾는다. --> has_x<T, decltype((void)T::x) 탐색
	// T가 A이므로, A::x는 존재하기 때문에 decltype((void)int)가 된다.
	// void 형변환으로 has_x<T, void>라는 특수화가 만들어져 이것을 우선으로 사용한다. -> 성공
	cout << has_x<B>::value; // false
	// 과정.
	// 위와 마찬가지로 특수화를 찾는다. --> has_x<T, decltype((void)T::x) 탐색
	// T가 B인데, B::x는 존재하지 않는다.
	// 하지만 SFINAE에 따라 컴파일 에러를 띄우지 않고, 특수화를 제외시킨다.
	// 사용할 수 있는 구조체가 has_x<T, void(디폴드)>밖에 없으므로 이를 사용 -> 실패
	cout << has_y<A>::value; // true
	cout << has_y<B>::value; // false

	cout << has_type<A>::value; // true
	cout << has_type<B>::value; // false
}
```

#### `void_t`
- `void_t` : 가변 인자를 받는 템플릿을 받는 void 타입을 가진 구조체이다.
- 가변 인자에 어떤 인자를 넣든 void가 되는 것이다. 그러나 템플릿 인자들 중 문법적으로 잘못된 인자가 들어온다면 void가 되는 대신 SFINAE에 의해 오버로딩 목록에서 제외된다.
- 이를 이용해 위와 같이 임의의 타입에 특정 변수나 타입이 존재하는지 컴파일 타임에 확인할 수 있다.
```cpp
// 매우 심플한 구현
template<typename...>
using void_t = void; // C++17 <utility>에 포함됨
```


참고자료
[[C++] std::void_t를 이용해 클래스에 특정 멤버가 있는지 확인하기. (tistory.com)](https://neurowhai.tistory.com/225)
