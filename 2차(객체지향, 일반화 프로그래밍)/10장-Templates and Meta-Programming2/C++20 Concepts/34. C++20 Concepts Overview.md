
### Concepts
---

- C++20에서 템플릿 인자에 대한 요구 사항을 지정하는 제약 조건을 템플릿에 적용하기 위한 확장으로 Concept를 사용한다.
- Concepts는 컴파일 시간에 템플릿 인자의 유효성 검사를 수행하게 할 수 있다.

- `std::enable_if`와 다른 점은?
	- Concepts가 더 가시성 있음
	- 디버깅 시 컴파일 타임 메시지가 깔끔함
	- 컴파일 시간을 더 단축시킴


- `concept` : 제약 조건을 나타내는 키워드
- `requires` : 제약 조건 리스트, 요구 사항들의 절이나 표현식을 나타내는 키워드


#### `concept` 키워드

```cpp
// 사용법
template<인자>
concept 이름 = 컴파일 타임에 표현 가능한 bool 표현식

// 예시
template<typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

template<Arithmetic T>
T add(T valueA, T valueB) {
	return valueA + valueB;
}

// auto의 추론에 Arithmetic이라는 제약조건을 적용한다.
auto add(Arithmetic auto valueA, Arithmetic auto valueB) {
	return valueA + valueB;
}

struct A {};

int main()
{
	// cout << add(A{}, A{}); // compile error 
}
```


#### `requires` 절

- `requires`문은 SFINAE처럼 동작한다.
- 템플릿 파라미터문장 뒤에 혹은 함수 선언 뒤에 사용할 수 있다.
```cpp
template<typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

template<typename T>
	requires Arithmetic<T>
T add(T valueA, T valueB) {
	return valueA + valueB;
}

template<typename T>
T add(T valueA, T valueB) requires (sizeof(T) == 4) {
	return valueA + valueB;
}
```

#### `concept`와 `requires` 혼용

- `concept`와 `requires`는 함께 쓰일 수 있다.
- 이 때 두 키워드에 들어갈 표현식은 컴파일 타임에 평가 가능한 표현식으로,
- `constexpr` 변수(`constexpr`함수는 불가능)나 `&&`/`||` 연산자를 사용한 기본 표현식 문장을 뜻한다.

```cpp
// concept 단독
template<typename T>
concept Arithmetic1 = std::is_arithmetic_v<T> && sizeof(T) >= 4;

template<Arithmetic1 T>
T add1(T valueA, T valueB) {
	return valueA + valueB;
}

// concept & requires 혼용
template<typename T>
concept Arithmetic2 = std::is_arithmetic_v<T>;

template<Arithmetic2 T>
requires (sizeof(T) >= 4)
T add2(T valueA, T valueB) {
	return valueA + valueB;
}

int main()
{
	// cout << add1(true, false); // compile error
	cout << add1(4, 5); // print 9
	// cout << add2('a', 'b'); // compile error
	cout << add2(4.5f, 4.5f); // print 9
}
```
