
### `requires` Expression
---

- `requires` 표현식에는 템플릿 인자에 적용할 제약조건을 작성한다.
- 제약 조건을 컴파일 타임에 따져 bool 타입으로 결정된다.
```cpp
// 예시
requires(인자){
	[SFINAE 표현]
	// 혹은
	requires [절]
}
```

```cpp
template<typename T>
concept MyConcept = requires(T a, T b){ // 아래의 조건을 만족해야 함
	a + b; // a와 b가 덧셈 연산이 가능하다
	a[0];  // a에 인덱스 접근이 가능하다
	a.x;   // a가 x라는 멤버를 가져야 한다
	a.f(); // a가 f()라는 함수를 가져야 한다.
	typename T::type; // T가 type이라는 필드를 가져야 한다.
};
```

- `concept`라이브러리를 사용해 제약 조건을 추가할 수도 있다.
```cpp
#include <concepts>
using namespace std;

// <concept> Library
// convertible_to<T> : T타입으로 암시적 형변환이 가능한지 확인
// same_as<T> : T와 같은 타입인지 확인

template<typename T>
concept MyConcept2 = requires (T a, T b) {
	{ a + 1 } -> std::convertible_to<float>; // a + 1이 float으로 암시적 형변환이 가능해야 함
	{ a * a } -> std::same_as<int>; // a의 제곱이 유효하며 값이 int여야 함
};

template<typename T>
void foo(T a, T b) requires MyConcept2<T>
{cout << "Possible";}

int main()
{
	int a = 1, b = 2;
	foo(a, b); // print "Possible"
}
```

#### `requires` Expression + Clause

- `requires` 표현식에 `requires` 절을 집어넣어, SFINAE 표현식에서 나온 값을 bool로 계산할 수 있다.
```cpp
template<typename T>
concept Arithmetic = requires { // 표현식 -> bool (인자 없음)
	T::value; // clause -> direct SFINAE(value가 없으면 직접적으로 SFINAE가 적용)
	requires std::is_arithmetic_v<T>; // clause -> SFINAE를 bool로 받아옴
};
```

- 반대로 `requires` 절에 `requires` 표현식을 집어넣을 수도 있다.
```cpp
template
```


#### `requires`과 `constexpr` 혼용

1. 변수로 사용
```cpp
template<typename T>
constexpr bool has_member_x = requires(T v) { v.x; };

struct A { int x; };

cout << has_member_x<A>;   // true
cout << has_member_x<int>; // false
```

- 조건문에 사용
```cpp
if constexpr (MyConcept<T>)
```

- `static_assert`에 사용
```cpp
template<typename T>
void foo(T v) {
	static_assert(requires { ++v; }, "no increment");
}

struct A {};

foo(A{}); // compile error "no increment"
```

- `constexpr`함수에 bool 리턴으로 사용
```cpp
template<typename Iter>
constexpr bool is_iterator() {
	return requires(Iter it) { *it++; };
}

int arr[2] = { 1,2 };
cout << is_iterator<decltype(arr)>(); // true
```

