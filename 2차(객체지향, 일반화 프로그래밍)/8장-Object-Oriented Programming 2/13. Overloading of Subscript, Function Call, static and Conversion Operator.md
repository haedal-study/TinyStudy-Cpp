
### Subscript Operator
---

- 아래첨자 연산자(Subscript Operator)를 오버로딩 해 클래스의 배열 요소에 `[]`연산자로 접근할 수 있다.
- 이 오버로딩 함수의 파라미터로는 int 말고도 여러 타입의 값을 받을 수 있다.
```cpp
struct A {
	int arr[5] = { 1,2,3,4,5 };

	int& operator[](int index) { //읽기/쓰기
		return arr[index];
	}
	int operator[](int index) const {// 읽기
		return arr[index];
	}
	int& operator[](char cIndex) {
		return arr[static_cast<int>(cIndex - '0')];
	}
};

A a;
a[1] = 3;
cout << a['1']; // print 3
```


### Multimentional Subscript Operator
---

- C++23부터 아래첨자 연산자에 다중 인자를 받을 수 있다.
```cpp
struct A {
	int operator[](int x, int y) { return x * y; }
};

A a;
cout << a[3,4] // print 12
```


### Function Call Operator
---

- 함수 호출 연산자(Function Call Operator)는 함수객체를 생성하거나 어떤 연산을 담당하는 클래스를 만들 때 주로 오버로드된다. (1차 43번 참고)
```cpp
#include <algorithm>

struct Descending{
	bool operator()(int a, int b){ return a > b; }
};

int array[] = {7,2,5,1};
std::sort(array, array+4, Descending{});
// 내림차순 정렬{7, 5, 2, 1}
```


### `static operator()` And `static operator[]`
---

- C++23에서는 연산자에 this 포인터를 전달하지 않고 효율적으로 연산을 수행하도록 `static` 키워드를 붙인 함수 호출 연산자, 아래 첨자 연산자를 오버로딩할 수 있다.
	- 객체의 상태를 고려하지 않아 비정적 연산자보다 효율적이다.
	- 멤버가 없는, 연산을 위한 함수 객체를 사용할 때에 효율적으로 쓸 수 있다.
```cpp
#include <numeric>

struct Multiply{
	static int operator()(int a, int b);
};
struct MyArray{
	static int operator[](int x);
};

int array[] = {2,3,4};
int factorial = std::accumulate(array, array + 3, 1, Multiply{});
```


### Conversion Operator
---

- 형변환 연산자(Conversion Operator)는 오버로딩 함으로써 해당 타입으로 암시적/명시적으로 형변환 할 수 있도록 해준다.
- `explicit` 키워드를 사용해 명시적으로만 형변환이 가능하도록 만들어 줄 수도 있다.
```cpp
struct A {
    operator bool() { return true; }
};

struct B {
    explicit operator bool() { return true; }
};

B b;
bool c1 = a;
// bool c2 = b; // error : 암시적 형변환 불가
bool c3 = static_cast<bool>(b);
```

