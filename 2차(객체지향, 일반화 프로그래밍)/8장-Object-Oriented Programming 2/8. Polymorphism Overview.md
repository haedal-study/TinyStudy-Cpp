
### Polymorphism
---

- 다형성(Polymorphism)이란 문맥 사용에 따라 행동이 달라지는 객체를 구성하는 것이다.

- 어떻게?
	- 다형성은 부모 클래스가 문맥에 따라 자식 클래스처럼 행동하는 것을 의미하며, 런타임에 이루어진다.
	- 부모 클래스에 메소드를 정의하고 자식 클래스에서 런타임에서 호출될 메소드를 재정의한다.

#### Polymorphism vs Overloading

- 오버로딩은 정적 다형성(static-polymorphism)이라고도 불리며 컴파일 시간에 바인딩이 이루어진다.(이른 바인딩)
- 일반적으로 polymorphism은 동적 다형성 즉, 런타임에 바인딩(늦은 바인딩)이 이루어진다.

- 바인딩(Binding)이란 함수 호출을 함수의 구현부와 연결하는 작업이다. 식별자를 주소로 변환하는 방식으로 이루어진다.
	- 이른 바인딩(early binding or static binding) : 컴파일러에 의해 객체의 타입이 식별되고 함수 호출과 함수의 주소를 연결한다.
	- 늦은 바인딩(late binding, or dynamic binding) : 컴파일러는 런타임에 객체의 종류를 식별하는 코드를 삽입하고, 올바른 함수 주소를 연결한다. 프로그램이 객체의 포인터의 주소를 읽고 해당 주소로 이동하는 추가 수준의 간접 참조(extra level of indirection)가 있어 이른 바인딩보다 느리다.
		- `virtual` 함수로 정의한 메소드가 늦은 바인딩으로 수행된다.

```cpp
struct A {
	void f() { cout << "A"; }
};

struct B : A {
	void f() { cout << "B"; }
};

void g(A& a) { a.f(); }

int main() {
	A a;
	B b;
	g(a); // print A
	g(b); // print A!
}

```
- 원래 의도는, g 함수에 b 객체를 넣으면 B 클래스의 속한 f 함수를 호출해야 한다.
- 그러나 컴파일러에 의해 함수 호출이 기본 클래스에 있는 정의에 연결된다. 함수 f에 대한 이른 바인딩이 이루어짐. 
- 이를 가상 함수(`virtual`)를 사용함으로써 해결할 수 있다. (다음 장)