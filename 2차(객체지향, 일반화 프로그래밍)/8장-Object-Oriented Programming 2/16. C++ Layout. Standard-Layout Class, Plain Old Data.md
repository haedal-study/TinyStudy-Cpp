
### Standard-Layout Class
---

- Standard-layout 클래스는 C의 구조체나 union와 동일한 메모리 레이아웃을 가지는 클래스로, 다른 언어와의 상호작용에 유용하다.
- `memcopy`가 가능하고 레이아웃이 C 프로그램에서 사용할 수 있다.

- Standard-layout은 다음을 만족한다.
	- 가상함수가 없음
	- 모든 비정적 멤버 변수들을 `private`, `protected`, `public` 중 하나로만 나타냄
	- 멤버 변수를 갖는 부모 클래스가 없음
	- 첫번째 비정적 데이터 멤버와 같은 타입의 기본 클래스가 없어야 함
- Standard-layout은 기본 클래스와 비정적 멤버에 재귀적으로 적용된다.

```cpp
struct StandardLayout1 {
	StandardLayout1(); // ok
	void f(); // 가상함수가 아니기에 표준 레이아웃 만족
};

// 기본 클래스가 멤버 변수가 없기에 표준 레이아웃 만족
class StandardLayout2 : StandardLayout1 { 
	int x, y; // 모든 변수가 private이기에 표준 레이아웃 만족
	StandardLayout1 y; // y의 타입이 기본 클래스와 같지만, 첫번재 멤버 변수가 아니라 만족
};

struct StandardLayout4 : StandardLayout1, StandardLayout2 {
	// 다중 상속. 오직 하나의 기본 클래스만 멤버 변수를 가지고 있어야 함.
};
```


### Plain Out Data(POD)
---

- POD는 Trivial copyable 조건과 Standard-layout 조건을 만족하는 구조체나 클래스이다.

- Trivial copyable 조건
	- 사용자 정의 복사/이동/기본 생성자, 소멸자, 복사/이동 할당 연산자가 없음.
	- 가상 함수가 없음.

- Standard-layout 조건
	- 모든 비정적 멤버 변수들을 `private`, `protected`, `public` 중 하나로만 나타냄
	- 첫번째 비정적 데이터 멤버와 같은 타입의 기본 클래스가 없어야 함
	- 가상 함수가 없음.

- POD는 기본 클래스와 비정적 멤버에 재귀적으로 적용된다.

```cpp
struct B
{
protected:
	virtual void Foo() {}
};

// A : Trivial도 Standard-Layout도 아님
struct A : B
{
	int a;
	int b;
	void Foo() override {} // Virtual function
};

// Trivial이지만 Standard-Layout은 아님
struct C
{
	int a;
private:
	int b;   // 접근 지정자를 하나만 쓰지 않음
};

// Standard-Layout이지만 Trivial이 아님
struct D
{
	int a;
	int b;
	D() {} // 사용자 정의 기본 생성자
};

struct POD
{
	int a;
	int b;
};
```
