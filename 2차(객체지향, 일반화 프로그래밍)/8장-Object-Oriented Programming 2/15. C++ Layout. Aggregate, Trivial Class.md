
### C++ Layout
---

- 레이아웃은 클래스, 구조체의 멤버가 메모리에 어떻게 정렬되는지를 나타내는 용어이다.
- 4가지 레이아웃이 있다.
	- Aggregate
	- Trivial Copyable
	- Standard Layout
	- Plain-old Data(POD)

- 왜 알아야 하나 : 레이아웃은 순수 C 언어의 API를 C++ 객체와 상호작용 하는지를 이해하고 최적화 목적에도 도움이 된다.

### Aggregate
---

- `{}`를 사용한 Aggregate Initialization을 지원하는 클래스나 구조체를 말한다.
- Aggregate Initialization :  Aggregate를 list-initializate 형태로 초기화하는 것이다.
- Aggregate : 다음 조건들을 만족하는 타입!
	- 배열 타입
	- 이런 클래스
		- 사용자 정의 생성자가 없는(C++11까지)
		- `private`/`protected` 지정자의 비정적 멤버변수가 없고 기본 클래스 없는
		- 가상 함수가 없는
		- 기본 클래스가 없는(C++17까지)
		- 비정적 멤버에 대한 `{}` or `=` 초기화가 없는(default 멤버 초기화가 없는)(C++14까지)
		- 초기화하지 않은 비정적 멤버(C++14까지)와 멤버 함수는 가능
		- `static` 멤버 변수와 멤버 함수는 가능

- Aggregate Initialization은 기본 클래스의 멤버에 재귀적으로 적용된다.
```cpp
struct S1 { int a, b; };
struct S2 { S1 s, t; };

int main() {
	S2 x[2] = {
		{ // S2 [0]
			{1,2}, // S1(s)
			{3,4}  // S1(t)
		},
		{ // S2 [1]
			{5,6}, 
			{7,8}
		}
	};

	// x와 y가 같다!
	S2 y[2] = { 1,2,3,4,5,6,7,8 };

	cout << x[1].s.a << x[1].t.b; // print 58
	cout << y[1].s.a << y[1].t.b; // print 58
	
	return 0;
}
```
1
```cpp
struct Aggregate {
	int x;
	int y[3];
	int z{ 3 };
	Aggregate() = default;
	Aggregate& operator=(const Aggregate&) {}; // 가능
private:
	void f() {}
};
```
2
```cpp
struct Aggregate1 {
	int x;
	struct Aggregate2 {
		int a;
		int b[3];
	} y;
};
	
Aggregate1 a{ 1, {2, {3,4,5}} };
Aggregate1 b = { 1, {2, {3,4,5}} };
```


### Trivial Class
---

- Trivial Class는 Trivial 복사(trivial copyable)가 가능한 클래스이다.
- Trivially Copyable : C++에서 특정 타입의 객체가 **안전하게 복사**될 수 있는지 여부를 나타내는 개념이다.
- Trivially copyable 타입은 메모리 블록 복사를 수행하는 `std::memcpy`같은 함수를 사용하여 안전하게 복사할 수 있다.
- Trivial Copyable은 다음을 만족한다.
	- 사용자 정의한 복사/이동/기본 생성자, 소멸자, 복사/이동 할당 연산자가 없다.
	- 가상 함수가 아니다.
	- 복사/이동/기본 생성자가 아닌 사용자 정의 생성자는 가능
	- 함수나 정적/비정적 멤버 변수 초기화도 가능
	- `private`/`protected` 멤버도 가능

- Trivial copyable는 기본 클래스와 비정적 멤버에 재귀적으로 적용된다.

```cpp
struct NonTrivial {
	NonTrivial(); // 사용자 정의 '기본' 생성자!라 안됨
	virtual void f(); // 가상함수라 안됨
};
struct Trivial1 {
	Trivial1() = default;
	Trivial1(int) {} // 사용자 정의 생성자 가능 (기본x)
	static int x; // static member도 가능
	void f();
private:
	int z{ 3 }; // private, 초기화도 가능
};
struct Trivial2 : Trivial1 { // ok, base class is trivial
	int Trivial1[3]; // Trivial을 만족하는 배열도 가능
};

Trivial1 t1(1);
Trivial1::x = 10;
Trivial2 t2;
```

