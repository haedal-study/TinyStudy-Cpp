
### Uniform Initialization
---
- **균일한 초기화(Uniform Initialization)**는 `{}`를 사용해 객체를 초기화하는 방법으로, 데이터 타입에 상관 없이 모든 객체를 초기화하는 방법이다.

- 장점
	- 타입 이름을 적지 않아도 되기 때문에 코드가 간결해진다.
	- "Most Vexing Parse"문제를 해결할 수 있다.

```cpp
struct Point {
	int x, y, z;
	Point(int _X, int _Y, int _Z)
		: x(_X), y(_Y), z(_Z)
	{}
};

Point add(Point a, Point b)
{
	return { a.x + b.x, a.y + b.y, a.z + b.z }; // uniform init
}

	auto p = add({ 1,2,3 }, { 1,0,1 }); // uniform init
	cout << p.x << p.y << p.z; // print 224
```


#### Most Vexing Parse 문제

- 직역하면 "가장 성가신 구문분석"
- 컴파일러가 함수 정의처럼 보이는  구문은 모두 함수 정의로 해석하는 문제
```cpp
struct A {
public:
	A() {std::cout << "Constructor!" << std::endl;}
};

A a(); // 아무것도 출력되지 않음. A를 리턴하는 함수를 정의한 것이라고 판단.
```

- 이를 해결하기 위해 균일한 초기화를 사용할 수 있다.


### Delegate Constructor
---
- 델리게이트 생성자(Delegate Constructor)는 같은 클래스 내의 다른 생성자를 호출하는 생성자를 의미한다.
- 여러 생성자에서 반복적으로 사용되는 코드의 양을 줄일 수 있다.
```cpp
struct A {
	int a;
	float b;
	bool c;
	// standard constructor:
	A(int a1, float b1, bool c1) : a(a1), b(b1), c(c1) {
		// do a lot of work
	}
	A(int a1, float b1) : A(a1, b1, false) {} // delegate constructor // 위 생성자의 코드를 재사용할 수 있음.
	A(float b1) : A(100, b1, false) {} // delegate constructor
};
```


### `explicit` 키워드
---

- `explicit` : 이 키워드를 붙이 생성자나 형변환 연산자에 암시적 형변환으로 초기화 되는 것을 막는다. 또한 단일 인자나 중괄호(`{}`)로 복사 초기화 하는 것도 불가능하다.

- `explicit`을 사용하는 이유
```cpp
struct MyString{
	MyString(int n); // 1 : 문자열 생성을 위해 n바이트 할당
	MyString(const char* p); // 2 : 문자열로 초기화
};
MyString str = 'a'; // char가 암시적으로 int로 형변환되어 1번 실행.
```

- 예시
```cpp
struct B {
	explicit B() {}
	explicit B(int) {}
	explicit B(int, int) {}
};

void f(const B&) {}

B b1;
// B b2 = {}; // 암시적 형변환
B b3{ 1 };
// B b4 = 1; // int -> B 암시적 형변환
B b5 = B{ 1 };
// B b6 = { 1,2 }; // error
// f({}); // error
// f({ 1 }); // error
f(B{ 1,2 });
```


### `[[nodiscard]]` and Class
---

`[[nodiscard]]` : 이 어트리뷰트가 붙은 함수의 리턴 값을 사용하지  않고 파기시키면 경고가 발생하게 됨.

- C++17부터 `class`와 `struct`에 `[[nodiscard]]` 어트리뷰트를 사용할 수 있다.
```cpp
struct [[nodiscard]] A {};
A f() { return A{}; }

auto x = f();
f(); // 경고
```

- C++20부터는 생성자에도 `[[nodiscard]]`를 붙일 수 있다.
```cpp
struct A{
	[[nodiscard]] A() {}
};
void f(A  {})

A a{};
f(A{});
A{} // 경고
```
