
### `const` Keyword
---

- `const` 멤버 함수 안에서는 멤버 변수를 변경하지 못한다. (`this` 포인터도 포함.)
- `mutable` 멤버 변수는 여전히 변경할 수 있다.
#### `const` Overloading
- `const`도 함수 시그니처이기 때문에 함수 오버로딩에 사용될 수 있다.
```cpp
class A {
	int x = 3;
public:
	int& get1() { return x; }
	int get1() const { return x; }
	int& get2() { return x; }
};

int main() {
	const A a1;
	cout << a1.get1(); // int get1() const 함수가 호출된다.
	// a1.get2(); // get2()는 A의 멤버 함수. a1은 const A
}
```
### `mutable` Keyword
---

- `mutable`로 선언된 멤버 변수는 `const` 클래스의 인스턴스이더라도 변경할 수 있다.
- 주로 대부분의 멤버가 변경하면 안 되지만, 몇 개는 변경해야 할 경우 쓰인다.
```cpp
struct A {
	int x;
	mutable int y;
};

int main() {
	const A a;
	// a.x = 10;
	a.y = 10;
}
```


### `using` Keyword
---

- 특정 클래스 안에서 타입의 별칭을 나타내기 위해 쓰일 수 있다.
```cpp
struct A {
	using type = int;
};

struct B : A {};

int main() 
{
	typename A::type a = 10;
	cout << a; // print 10
	typename B::type b = 20;
	cout << b; // print 20
}
```

- 상속의 속성(접근제한)을 변경할 수 있다.
```cpp
struct A {
protected:
	using type = int;
};

struct B : A {
	using A::type;
};

int main() {
	// typename A::type a = 10;
	typename B::type b = 20; // A의 type은 protected지만, 상속된 B의 type은 public
	cout << b;
}
```

### `friend` Keyword
---

- `friend` 클래스는 `friend`키워드가 붙은 클래스의 private, protected 멤버에 접근할 수 있다. 

- 특징
	- 비대칭이다 : A가 B의 친구라고 B가 A의 친구가 되는 것은 아니다(ㅠㅠ)
	- 추이적이지 않다 : A가 B의 친구이고, B가 C의 친구여도 A가 C의 친구는 아니다.
	- 상속되지 않는다 : A가 B의 친구일 때, B를 상속한 C는 A의 친구가 아니다.

```cpp
class B;

class A {
	friend class B; // A의 친구 B
	int x;
};

class B {
	int f(A a) { return a.x; }
};

class C : B {
	// int g(A a) { return a.x; } // 상속x
};
```

- `friend` 함수를 클래스에 선언하여 클래스의 private, protected 멤버에 접근할 수 있다. (friend 함수는 멤버 함수가 아니다!!)
- 보통 스트림 연산자`operator<<`를 오버라이딩 하는데 쓰인다.
```cpp
class A {
	int x = 3;

	friend int foo(A a); // 멤버함수 아님
};

int foo(A a) {
	return a.x;
}

int main() {
	A a;
	cout << foo(a); // print 3
}
```


### `delete` Keyword
---

- `delete` 키워드를 붙인 멤버 함수는 사용할 수 없게 된다. (사용 시 컴파일 에러 발생)
- 주로 컴파일러에 의한 기본 복사, 이동 생성자로 인해 오류가 발생하는 것을 막기 위해, 명시적으로 메서드를 지우는데에 사용된다.

```cpp
struct A {
	A() = delete;
	A(const A&) = delete;
};

int main() {
	// A a; // 기본 생성자가 삭제되었기 때문에 객체를 생성할 수 없다.
}
```