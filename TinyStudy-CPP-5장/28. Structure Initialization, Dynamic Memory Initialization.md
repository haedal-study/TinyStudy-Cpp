
### 구조체 초기화
---

*  C++03에서 구조체를 초기화 할 때, 다음과 같이 사용할 수 있다.
```cpp
struct S{
	unsigned x;
	unsigned y;
};

S s1; // x,y는 초기화되지 않음
S s2 = {}; // x,y가 0으로 초기화 됨.
S s3 = {1,2}; // x = 1, y = 2로 초기화
S s4 = {1}; // x = 1, y = 0으로 초기화

// C++11에서는 다음과 같이 초기화가 가능함.
S s5{1,2};
```


* Non-Static Data Member Initialization (NSDMI) : C++11이후 정적 상수가 아닌 멤버 변수도 변수 선언과 동시에 초기화가 가능하게 되었다. (이전에는 생성자나 메서드에서 초기화했다.)

```cpp
struct S{
	unsigned x = 3; // equal init
	unsigned y{3};  // brace init
};
```


* C++20부터 사용할 수 있는 Designated initializer list.
	* 초기화할 멤버가 많을 때, 가독성 높게 초기화할 수 있다.
```cpp
struct A{
	int x, y, z;
};
A a{.x = 1, .y = 2, .z = 3};

void f1(bool a, bool b, bool c, bool d){}

struct B{bool a, b, c, d;};

f1({.a = true, .c = true}); // a,c만 지정되고, b,d는 false로 자동 초기화된다.
```


* 구조체 바인딩 : 변수들을 이니셜라이저의 요소들에 바인딩한다.

```cpp
struct S
{
	int x = 1;
	int y = 2;
}a;

auto [x1, y1] = a; // 구조체를 사용해 초기화

int b[2] = {2,3};
auto [x2,y2] = b; // 배열을 사용해 초기화

auto [x3,y3] = std::tuple<float,int>{3.0f, 2}; // 튜플을 사용해 초기화
```


### Dynamic Memory Initialization
---

```cpp
int* a1 = new int(4); // 값 4 할당
int* a2 = new int[4]{()}; // 크기 4의 배열을 0으로 할당.
```
