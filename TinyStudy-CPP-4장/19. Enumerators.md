
### 열거자(Enumaerator)
---

* enum : 이름이 붙은 정수형 상수 집합을 그룹화한 데이터 타입.

* 발생할 수 있는 오류
```cpp
enum Color {BLACK, BLUE, RED };
enum Fruit {APPLE, CHERRY };

Color c = BLACK;  // int: 0
Fruit f = APPLE;  // int: 0
bool b = (c == f) // Color와 Fruit은 다름에도, b는 true
```

### Enum class
---

* enum class : 기존 enum의 특징인 int로의 암시적 형변환을 막아 타입 안정성이 강화된 데이터 타입
```cpp
enum class Color {BLACK, BLUE, RED};
enum class Fruit {APPLE, CHERRY };

Color c = Color::BLACK;  // int: 0
Fruit f = FruitAPPLE;  // int: 0
bool b = (c == f); // 컴파일 에러: Color와 Fruit은 완전히 다른 타입임.

int a1 = Color::BLUE; // 컴파일 에러
int a2 = Color::BLUE + Color::RED; // 컴파일 에러
int a3 = (int) Color::BLUE; // 명시적 형변환(가능)
```

### enum/enum class의 특징
---

1. 비교 가능(enum class의 경우,같은 타입끼리만) 
2. 자동으로 오름차순으로 값이 매겨진다.
3. 별칭을 넣을 수 있다.
4. C++11에서는 바탕 형식(underlying type) 설정 가능
	* 바탕 형식이란 enum값이 실제로 저장되는 정수 형식을 의미한다. C++ 표준에서는 이 형식을 컴파일러가 결정하게 되고, 이는 컴파일러마다 다른 크기의 enum 값을 결정하게 될 수도 있어서 문제가 발생할 수 있다.

```cpp
enum class Color : int8_t {RED, GREEN, BLUE};
```

5. C++17에서는 direct-list-initialization이 가능하다.
```cpp
enum class Color { RED, GREEN, BLUE }; 
Color a{2}; // Color::BLUE와 같음
```

6. C++17에서는 어트리뷰트를 집어넣을 수 있다.
```cpp
enum class Color {RED, GREEN, BLUE [[deprecated]]};
```

7. C++20에서는 복잡성을 줄이기 위해 열거형 식별자를 지역 범위 안에 넣을 수 있다.
```cpp
enum class Color { RED, GREEN, BLUE };

Color x = Color::BLUE;

switch (x)
{
	using enum Color;
case RED:
	break;
case GREEN:
	break;
case BLUE:
	break;
default:
	break;
}
```

### enum 안전 수칙들, constexpr

1.  enum 변수를 무조건 초기화하자.
2. C++17에서 바탕 형식 이상의 값을 초기화 하지 말도록 주의하자.
```cpp
enum Color : uint8_t {RED, GREEN, BLUE};
Color value = 256; // undefined behavior
```

* 명시적으로 바탕 형식을 지정하지 않은 enum은 범위를 벗어나는 값을 허용하지 않음.
```cpp
enum Color { RED }; 
enum Fruit : int { APPLE }; 
enum class Device { PC }; 
// constexpr Color a1 = (Color) -1; 컴파일 에러
const Color a2 = (Color) -1; // ok 
constexpr Fruit a3 = (Fruit) -1; // ok 
constexpr Device a4 = (Device) -1; // ok
```
