# [C++ Philosophy]

### 제로 오버헤드 원칙 (zero-cost abstraction)
: 프로그램의 추상화나 모듈화를 위해 사용되는 기능들이 추가적인 비용을 발생시키지 않도록 함.

### 정적 타입 언어
: 변수의 타입을 컴파일 시점에 결정함
: 컴파일 시점에 많은 버그를 잡을 수 있음.
: 컴파일러가 타입 정보를 이용해 최적화를 수행할 수 있음
: 런타임 시점에 타입 오류가 발생할 가능성을 줄여줌 -> 런타임 효율성이 증진됨
: 프로그램의 안정성과 신뢰성을 높일 수 있음
: 코드 가독성 향상
: 사용자가 변수의 데이터 타입을 정의할 수 있도록 허용함

### 프로그래밍 모델
: 시스템을 여러 개별적인 구성 요소로 분할하는 것을 의미함
: 개발자는 소프트웨어의 특정 부분을 수정하거나 개선할 때 다른 부분에 영향을 미치지 않도록 보장할 수 있음
: 실제로 문제를 해결하는 경우에만 기능을 추가하고, 전체 제어를 허용함
=> 시스템 전체의 안정성을 높이고, 코드의 재사용성을 높일 수 있음

### 예측 가능한 런타임
: 가비지 컬렉터를 사용하지 않음
: 동적 타입 시스템이 없음 -> 실시간 시스템에 적합함

**가비지 컬렉터란?
프로그래밍 언어나 런타임 환경이 자동으로 동적으로 할당된 메모리에서 더 이상 사용되지 않는 객체들을 탐지하고 해제하는 기능을 말함
C++은 명시적으로 메모리를 할당하고 해제해야 함

### 낮은 자원 사용
: 소프트웨어가 메모리와 에너지를 적게 사용할수록 제한된 하드웨어 리소스를 가진 플렛폼에서도 잘 동작함

### 정적 분석에 적합함
그러므로 안정성이 중요한 소프트웨어에 사용됨

**정적 분석이란?
코드를 실행하지 않고도, 소프트웨어의 구조, 동작 및 잠재적인 결함을 검사하는 프로세스를 말함

### 이식성
: 최신 C++ 표준은 높은 이식성을 가지고 있음
: 그러므로 다양한 운영체제, 하드웨어 플랫폼 및 컴파일러에서 소프트웨어를 실행할 수 있음

**이식성이란?
소프트웨어가 다양한 플랫폼과 환경에서 동작할 수 있는 능력을 나타냄
