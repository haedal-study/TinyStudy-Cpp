
### Type Punning
---

* **Strict Aliasing Rule** : 객체에 접근할 때는 그것과 동일한 타입이나 char 형으로만 접근해야 한다, 타입이 다른 포인터를 통해 동일한 메모리에 접근하면 안 된다는 C99의 규칙이다.

* **Pointer Aliasing** : 동일한 메모리 위치를 서로 다른 포인터들이 가리키는 상황이다.

* **Type Punning** : "프로그래밍 언어의 공식적인 방법으로 얻기 어렵거나 불가능한 이득을 얻기 위해 프로그래밍 언어의 타입 시스템을 우회하는 행위."

	* 하나의 데이터 타입으로 저장된 값을 다른 데이터 타입으로 해석하는 기술이다.
	* 동일한 메모리 위치에 서로 다른 타입의 포인터를 통해 접근하는 방법으로 이루어진다.
	* 컴파일러는 이를 Strict Aliasing 규칙을 위반하지 않는다고 가정한다. 대신 undefined behavior로 분류한다.
	* GCC 컴파일러에서는 `-Wstrict-aliasing` 옵션을 활성화하여 strict aliasing 규칙을 위반한 코드에 대한 경고를 제공한다.

```cpp
// 아래 함수는 분기로 인해 CPU 명령어 파이프라인이 깨지기에, 최적화 없이는 느리다.
float abs(float x) {
	return (x < 0.0f) ? -x : x;
}

// type punning을 사용해 직접 최적화한 방법(Undefined behavior이다.)
float abs(float x) { 
	unsigned uvalue = reinterpret_cast<unsigned&>(x); // float형 x를 unsigned형으로 해석
	unsigned tmp = uvalue & 0x7FFFFFFF; // 부호비트를 0으로 바꾸어 양수로 만듦 (uvalue의 비트 & 0111 1111 1111 ... 1111)
	return reinterpret_cast<float&>(tmp); // 다시 float로 해석
} 
```


### `memcpy` and `std::bit_cast`
---

* undefined bahavior를 피하면서 특정 유형의 값을 다른 유형의 값으로 해석하는 방법으로는 `memcpy`를 사용하는 방법이 있다.
```cpp
float v1 = -32.3f;
unsigned v2;
std::memcpy(&v2, &v1, sizeof(float));
v2 = v2 & 0x7FFFFFFF;
std::memcpy(&v1, &v2, sizeof(float));
cout << v1; // print 32.3
```

- C++20에서는 `reinterpret_cast`의 안전한 버전 대체제로 `std::bit_cast`를 사용할 수 있다.
```cpp
float v1 = -32.3f;
unsigned v2 = bit_cast<unsigned>(v1);
v2 = v2 & 0x7FFFFFFF;
v1 = bit_cast<float>(v2);
cout << v1; // print 32.3
```

참고자료
[Warning Options (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)
[What is Strict Aliasing and Why do we Care? · GitHub](https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8)
[Type-punning and strict-aliasing (qt.io)](https://www.qt.io/blog/2011/06/10/type-punning-and-strict-aliasing)
