
### Non-allocating Placement
---

* 이미 할당된 객체의 메모리 주소를 명시적으로 지정한다.
* `(ptr) type` 이렇게 사용한다.
```cpp
// 스택 메모리에 지정
char buffer[8];
int* x = new (buffer) int;
short* y = new (x+1) short[2];
// x,y를 해제할 필요 없음

// 힙 메모리에 지정
unsigned* buffer2 = new unsigned[2];
double* z = new (buffer2) double;
delete[] buffer2;
// delete[] z; 보다는 buffer2를 지우자.
```


### Non-Allocating Placement and Objects
---

*  non-trivial* 객체의 경우, 런타임에 객체가 범위 밖으로 벗어난 것을 탐지할 수 없기 때문에, 명시적으로 소멸자를 호출해줘야 한다.
```cpp
struct A
{
	~A() {cout << "destructor"; }
}

char buffer[10];
auto x = new (buffer) A();
// delete x; // x는 heap 메모리에 생성되지 않았기 때문에 객체 A의 소멸자를 호출해야 함.
x->~A();
```

*trivial : C++에서 "하는 일이 없다"는 의미로 쓰임. trivial object는 기본 생성자가 하는 일이 없는 경우에 사용한다. (ex. 가상함수가 있는 객체는 생성자에서 가상함수테이블을 초기화하기 때문에 non-trivial 객체이다.)


### Non-Throwing Allocation
---

* `new`가 할당에 실패했을 때 예외를 발생시키지 않도록 하는 방식이다. 
* `std::bad_alloc` 예외를 뱉지 않는 대신 `NULL`포인터를 반환한다.(주의, `new`가 0 size 할당을 할 때도 `NULL`리턴함.)
* `std::nothrow`로 생성된 객체가 예외를 뱉지 않는다는 말은 아니다.

```cpp
int* array = new (std::nothrow) int[very_large_size];
```

