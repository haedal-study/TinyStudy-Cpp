## 정의
레퍼런스(T&)는 기존 변수에 대한 별명, 즉 다른 이름을 의미한다. 레퍼런스를 사용하면, 원본 변수와 동일한 메모리 주소를 공유하면서 원본 변수를 직접 조작할 수 있다.
## 특징
포인터는 자체적인 메모리 주소와 크기를 가진다(스택에 저장됨). 반면, 레퍼런스는 원본 변수와 동일한 메모리 주소를 공유한다. 컴파일러는 내부적으로 참조를 포인터로 구현할 수 있지만, 레퍼런스와 포인터를 다르게 취급한다.
## 레퍼런스가 포인터보다 안전한 이유
레퍼런스는 NULL 값을 가질 수 없기 때문에 항상 유효한 저장 공간에 연결되어 있다고 가정할 수 있다. 
레퍼런스는 한 번 초기화되면 변경될 수 없다. 즉, 레퍼런스가 한 번 어떤 객체를 참조하게 되면, 그 레퍼런스를 다른 객체로 변경할 수 없다. 이는 실수로 레퍼런스가 다른 대상을 가리키게 되는 오류를 방지한다. 반면에 포인터는 언제든지 가리키는 대상을 변경할 수 있다. 
레퍼런스는 선언될 때 반드시 초기화되어야 한다. 이는 레퍼런스가 항상 유효한 객체에 연결되어 있음을 보장한다.
## 사용 예시
- 레퍼런스 문법 : T& var = ...
```
int& a; // 컴파일 에러: 초기화가 없음
int& b = 3; // 컴파일 에러: "3"은 변수가 아님

int c = 2;
int& d = c; // 유효한 초기화
int& e = d; // 유효한 초기화
++d; // c의 값 증가
++e; // c의 값 다시 증가
cout << c; // 출력: 4

int a = 3;
int* b = &a; // 포인터
int* c = &a; // 포인터
++b; // 포인터 'b'의 값을 변경 (메모리 주소 증가)
++*c; // 'a'의 값을 변경 (a = 4)

int& d = a; // 레퍼런스
++d; // 'a'의 값을 변경 (a = 5)
```
## 함수 인자 전달 사용 예시
```
void f(int* value) {} // value는 nullptr일 수 있음

void g(int& value) {} // value는 절대 nullptr이 될 수 없음

int a = 3;
f(&a); // ok
f(0); // 권장되지 않음. nullptr 전달
//f(a); // 컴파일 에러. a는 포인터가 아니라 int 타입

g(a); // ok
//g(3); // 컴파일 에러. 3은 참조할 수 있는 변수가 아님
//g(&a); // 컴파일 에러. &a는 int의 주소를 가리키는 포인터임
```
- 배열을 인자로 넘기는 방법
```
void f(int (&array)[3]) { // 고정 크기 배열을 인자로 받는 함수
    cout << sizeof(array);
}

void g(int array[]) { // 크기를 지정하지 않은 배열을 인자로 받는 함수
    cout << sizeof(array);
}

int A[3], B[4];
int* C = A;

f(A); // ok
// f(B); // 컴파일 에러: B는 크기가 4
// f(C); // 컴파일 에러: C는 포인터
g(A); // ok
g(B); // ok. 포인터 크기 출력
g(C); // ok. 포인터 크기 출력
```
## 레퍼런스 - 배열
```
int A[4];
int (&B)[4] = A; // A 배열에 대한 참조, B는 A와 같은 4개의 int 원소를 가짐
int C[10][3];
int (&D)[10][3] = C; // C 배열에 대한 참조, D는 C와 같은 10x3의 2차원 배열을 참조

auto c = new int[3][4]; // 타입은 int (*)[4], "4개의 int를 가진 배열에 대한 포인터"로 읽음

// 배열 크기 계산
int array[4];
int size1 = (&array)[1] - array;
int size2 = *(&array + 1) - array;
cout << size1; // 4 출력
cout << size2; // 4 출력
```
## 구조체 멤버 접근
C++에서는 객체에 접근하고 그 멤버를 사용하기 위해 점(.) 연산자와 화살표(->) 연산자를 사용한다.
- 점(.) 연산자
	- 로컬 객체와 레퍼런스에 사용
- 화살표(->) 연산자
	- 포인터를 통해 객체에 접근할 때 사용
```
struct A {
    int x;
};

A a;        // 로컬 객체
a.x;        // 점(.) 연산자 사용: 객체 a의 멤버 x에 접근

A& ref = a; // 참조
ref.x;      // 점(.) 연산자 사용: 참조 ref를 통해 객체 a의 멤버 x에 접근

A* ptr = &a; // 포인터
ptr->x;      // 화살표(->) 연산자 사용: 포인터 ptr이 가리키는 객체의 멤버 x에 접근, *ptr.x와 동일
```
