# 중괄호 초기화 (Uniform Initilization)
C++11에서 도입된 초기화 방식으로, 중괄호를 사용하여 객체를 초기화하는 방법이다. 장점으로는 다음과 같다.
- 함수 인자나 함수 반환 값에서 타입 이름을 중복해서 쓰지 않아도 됨
```
// 기존 방식
struct Point {  
    int x, y;  
    Point(int x1, int y1) : x(x1), y(y1) {}  
};  
  
Point add(Point a, Point b) {  
    return Point(a.x + b.x, a.y + b.y);  
}  
  
int main() {  
    Point c = add(Point(1, 2), Point(3, 4)); // 타입 이름 'Point'를 여러 번 사용  
    return 0;  
}
```

```
// C++11 중괄호 초기화 방식
struct Point {
    int x, y;
    Point(int x1, int y1) : x(x1), y(y1) {}
};

Point add(Point a, Point b) {
    return { a.x + b.x, a.y + b.y }; // 타입 이름을 생략하고 중괄호 초기화 사용
}

int main() {
    auto c = add({1, 2}, {3, 4}); // 중괄호 초기화 사용
    return 0;
}

```
- 생성자가 함수 선언으로 해석되는 경우를 피할 수 있다.
```
struct A {  
    A(int) {}  
};  
struct B {  
    // A a(1); // 함수 선언으로 해석. 컴파일 오류 발생  
    A a{2}; // 생성자 호출  
};
```
# 생성자와 상속
클래스 생성자는 상속되지 않는다. 파생 클래스의 생성자는 기본 클래스의 생성자를 암시적 또는 명시적으로 호출해야 한다. 기본 클래스 생성자가 먼저 호출되고 그 다음 파생 클래스 생성자가 호출된다.
```
#include <iostream>
using namespace std;

struct A {
    A() { cout << "A"; }
};

struct B1 : A { // "A()"를 암시적으로 호출
    int y = 3;  // 그런 다음, "y = 3
};

struct B2 : A { // "A()"를 명시적으로 호출
    B2() : A() { cout << "B"; }
};

int main() {
    B1 b1; // 출력: "A"
    B2 b2; // 출력: "A", 그 다음 "B"
    return 0;
}
```
# 위임 생성자 (Delegate Constructor)
대부분의 생성자는 개별적인 작업을 수행하기 전에 동일한 초기화 작업을 수행해야 한다. 이러한 초기화 작업을 각 생성자마다 반복하게 되면 코드 중복이 발생하고 유지보수가 어려워진다. 이를 위한 해결책으로 C++11에서는 클래스 내의 한 생성자가 다른 생성자를 호출하여 초기화를 대신하게 하는 위임 생성자 기능을 도입했다.
```
#include <iostream>
using namespace std;

struct A {
    int a;
    float b;
    bool c;

    // 기본 생성자
    A(int a1, float b1, bool c1) : a(a1), b(b1), c(c1) {
        // 많은 초기화 작업 수행
        cout << "Standard constructor called" << endl;
        initialize();
    }

    // 위임 생성자: bool 값을 기본값 false로 설정
    A(int a1, float b1) : A(a1, b1, false) {
        cout << "Delegating constructor (int, float) called" << endl;
    }

    // 위임 생성자: int 값을 기본값 100, bool 값을 기본값 false로 설정
    A(float b1) : A(100, b1, false) {
        cout << "Delegating constructor (float) called" << endl;
    }

private:
    void initialize() {
        // 초기화 작업 코드
        cout << "Initialization work done" << endl;
    }
};

int main() {
    A obj1(10, 20.5f, true);  // Standard constructor 호출
    A obj2(10, 20.5f);        // 위임 생성자 (int, float) 호출
    A obj3(20.5f);            // 위임 생성자 (float) 호출

    return 0;
}
```
# explicit 키워드\
암시적 변환은 때때로 의도치 않은 방식으로 작동할 수 있다. 예를 들어, 단일 인수를 받는 생성자가 있을 때, 해당 생성자는 암시적으로 호출될 수 있으며, 이는 예기치 않은 동작을 초래할 수 있다.
```
struct MyString {
    MyString(int n);          // (1) n 바이트를 할당
    MyString(const char *p);  // (2) raw 문자열로부터 초기화
};

MyString string = 'a';  // (1) 호출, 암시적 변환!!
```
explicit 키워드는 생성자로 초기화 시 암시적 변환이나 복사 초기화를 허용하지 않도록 지정한다. 이는 특정 상황에서 의도치 않은 암시적 변환을 방지하는데 유용하다.
```
struct MyString {
    explicit MyString(int n);          // (1) n 바이트를 할당
    MyString(const char *p);           // (2) raw 문자열로부터 초기화
};

MyString string = 'a';  // 오류! explicit로 인해 암시적 변환 불가
```

- explicit 키워드 사용되지 않은 경우
```
struct A {  
    A() {}  
    A(int) {}  
    A(int, int) {}  
};  
void f(const A&) {}  
  
int main() {  
    A a1 = {}; // ok  
    A a2(2); // ok. A(int) 호출  
    A a3 = 1; // ok. A(int) 호출  
    A a4{4, 5}; // ok. A(int, int) 호출  
    A a5 = {4, 5}; // ok. A(int, int) 호출  
  
    f({}); // ok: 기본 생성자를 호출하여 임시 객체를 생성하고 이를 const A&로 받음  
    f(1); // ok: A(int) 생성자를 호출하여 임시 객체를 생성하고 이를 const A&로 받음  
    f({1}); // ok: A(int) 생성자를 호출하여 임시 객체를 생성하고 이를 const A&로 받음  
}
```

- explict 키워드 사용 시
```
struct B {  
    explicit B() {}  
    explicit B(int) {}  
    explicit B(int, int) {}  
};  
void f(const B&) {}  
  
int main() {  
    // B b1 = {}; // 암시적 변환발생. 컴파일 오류  
    B b2(2); // ok  
    // B b3 = 1; // 암시적 변환발생. 컴파일 오류  
    B b4{4, 5}; // ok. B(int, int) 호출  
    // B b5 = {4, 5}; // 암시적 변환발생. 컴파일 오류  
    B b6 = (B) 1; // ok. 명시적 변환 사용  
  
    // f({}); // 중괄호 초기화 리스트를 'B' 구조체의 매개변수 유형으로 암시적 변환할 수 없음  
    f(B{});  
    // f(1); // 오류: 암시적 변환을 통해 int에서 B로 변환할 수 없음  
    // f({1}); // 오류: 암시적 변환을 통해 int에서 B로 변환할 수 없음  
    f(B{1}); // ok: 명시적 생성자를 사용하여 임시 객체를 생성하고 이를 const B&로 받음  
}
```
# `[[nodiscard]]`
`[[nodiscard]]` 속성은 함수나 생성자에서 반환되는 값을 사용하지 않을 경우 컴파일 오류를 발생시키도록 하는 기능이다.
- C++17의 `[[nodiscard]]` 속성
	- 클래스/구조체에 적용할 수 있음
```
[[nodiscard]] struct A {};

A f() { return A{}; }

int main() {
    auto x = f(); // ok, 반환 값을 사용함
    f();          // 경고: 반환 값을 사용하지 않음
    return 0;
}
```
- C++20의 `[[nodiscard]]` 속성
	- 생성자에 적용할 수 있음
```
struct A {
    [[nodiscard]] A() {} // 생성자에 [[nodiscard]] 적용, 이유를 추가할 수도 있음
};

void f(A) {}

int main() {
    A a{};      // ok, 객체를 생성하고 사용함
    f(A{});     // ok, 생성된 객체를 함수 인자로 사용함
    A{};        // 경고: 생성된 객체를 사용하지 않음
    return 0;
}
```
