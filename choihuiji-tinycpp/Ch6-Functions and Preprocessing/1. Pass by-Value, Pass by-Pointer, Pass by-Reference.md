## Call-by-value
함수로 인자를 넘길 때 복사본을 만들어 함수의 매개변수에 할당하는 방식이다. 
- 장점
	- 원본 인자에 영향을 주지 않음
- 단점
	- 복사된 인자가 큰 경우 성능 저하 발생
- 사용 시기
	- 기본 데이터 타입 및 작은 객체 (<= 8 바이트)
- 사용을 피해야 할 경우
	- 고정 크기 배열을 인자로 사용할 경우
		- C++의 배열은 함수에 전달될 때 포인터로 바뀌기 때문에 배열의 전체 내용이 복사되지 않고, 배열의 크기 정보도 손실
	- 큰 객체를 인자로 사용할 경우
## Call-by-pointer
함수의 인자로 변수의 주소를 복사하여 전달하는 방식이다.
- 장점
	- 함수 내에서 원본 변수의 값을 직접 변경할 수 있음
	- 인자가 복사되지 않아 빠름
- 단점
	- 인자가 널 포인터일 수 있음
	- 포인터의 역참조는 값에 직접 접근하는 것보다 느릴 수 있음
- 사용 시기
	- 배열을 다룰 때. 배열을 읽기 전용으로만 사용할 경우 const T* 를 사용하여 함수가 배열 내용을 변경하지 못하도록 할 수 있음
- 사용을 피해야 할 경우
	- 위에서 언급한 경우를 제외하고는 모든 다른 경우에서 피하는 것이 좋음
## Call-by-reference
함수의 인자로 변수의 참조를 복사하여 할당하는 방식이다.
- 장점
	- 인자 값 변경 가능. 포인터를 사용할 때보다 더 좋은 가독성을 제공
	- 인자가 복사되지 않기 때문에 빠름
	- 참조는 반드시 초기화되어야 하므로, 널 포인터의 문제를 피할 수 있음
	- const T&를 사용하지 않는 한, 암시적 타입 변환이 발생하지 않음
- 사용 시기
	- 포인터를 제외한 모든 경우에 사용할 수 있음
- 사용을 피해야 할 경우
	- 값에 의한 전달이 성능상의 이점을 제공하거나, 내장 데이터 타입 및 작고 복사가 간단한 객체에 대한 가독성을 향상시킬 때
```
struct MyStruct;  
void f1(int a); // 값에 의한 전달  
void f2(int& a); // 참조에 의한 전달  
void f3(const int& a); // 상수 참조에 의한 전달  
void f4(MyStruct& a); // 참조에 의한 전달  
void f5(int* a); // 포인터에 의한 전달  
void f6(const int* a); // 상수 포인터에 의한 전달  
void f7(MyStruct* a); // 포인터에 의한 전달  
void f8(int*& a); // 포인터를 참조에 의해 전달  
//--------------------------------------------------------------  
  
int main() {  
    char c = 'a';  
    f1(c); // ok, 값에 의한 전달 (암시적 변환 가능)  
    // f2(c); // 컴파일 오류, 다른 타입  
    f3(c); // ok, 값에 의한 전달 (암시적 변환 가능)  
}
```