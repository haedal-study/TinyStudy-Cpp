## 구조체(struct)
- 서로 다른 타입의 변수들을 하나의 단위로 묶는 데 사용
```
struct A {
	int x;
	char y;
}
```
- 구조체가 정의된 후, 그 정의를 사용하여 하나 이상의 변수를 선언할 수도 있음
```
struct A {
	int x;
} a, b;
```
- 구조체 내부에 이름 없는 열거형을 선언할 수 있음
```
struct A {
	enum {X, Y}
};

A::X; // 열거형의 멤버에 접근 가능
```
- 함수 내부와 같은 지역 스코프(local scope)에서도 구조체를 선언할 수 있음
```
int f() {
    struct A {
        int x;
    } a;
    return a.x;
}
```
### Unnamed Struct, Anonymous Struct
- 이름 없는 구조체(Unnamed Struct)
	- 이름은 없지만, 변수에 타입을 연결하여 선언할 수 있는 구조체
- 익명 구조체(Anonymous Struct)
	- 이름도 없고, 타입명도 별도로 지정되지 않는 구조체

**C++표준은 이름 없는 구조체는 허용하지만, 익명 구조체는 허용하지 않는다.**
```
struct {int x;} my_struct; // 이름 없는 구조체 선언 및 변수 my_struct 생성

struct S {
    int x;
    struct { int y; }; // 익명 구조체. `-Wpedantic` 옵션을 사용하는 컴파일러는 경고로 지적함
};
```
---
## bitfield
- 구조체 내에서 사전에 정의된 비트 너비를 가진 변수
```
struct S1 {
    int b1 : 10; // 10비트 너비를 가진 비트필드
    int b2 : 10; // 10비트 너비를 가진 비트필드
    int b3 : 8;  // 8비트 너비를 가진 비트필드
}; // sizeof(S1) : 4바이트
```
- 비트필드가 새로운 저장 단위에서 시작하게 강제할 수 있음
```
struct S2 {
    int b1 : 10;
    int : 0; // 다음 필드가 새로운 저장 단위에서 시작하도록 리셋
    int b2 : 10; // 32비트 경계에서 시작
};
```
---
## union
- 다양한 데이터 타입을 같은 메모리 위치에 저장할 수 있게 해주는 데이터 타입
- 멤버 중 가장 큰 데이터 타입의 크기만큼만 메모리를 차지함
```
union A {
	int x;
	char y;
}; // sizeof(A): 4

A a;

a.x = 1023; // bits: 00..000001111111111

a.y = 0; // bits: 00..000001100000000

cout << a.x; // print 512 + 256 = 768
```
- 리틀 엔디안 시스템에서는 값의 바이트가 메모리에 역순으로 배치되므로, y에 해당하는 바이트는 x의 값에서 가장 낮은 바이트(즉, 가장 오른쪽 바이트)를 차지함
- C++에서는 이름 없는 유니온(anonymous union)을 허용
- C++17부터는 std::variant를 도입하여 타입 안정성을 제공