# [Constants and Literals | const]

## 상수와 리터럴
상수는 컴파일 타임에 평가할 수 있는 표현식임   
리터럴은 상수에 할당할 수 있는 고정된 값임   
형식적으로 리터럴은 C++ 프로그램에서 소스 코드에 포함된 상수 값을 나타내는 토큰임

리터럴 타입
- 스칼라 타입인 bool, char, int, float, double의 구체적인 값
- const char[] 타입의 문자열 리터럴
- nullptr
- 사용자 정의 리터럴

## const 키워드
초기화된 후에 값을 변경하지 않는 객체를 나타냄   
(const 변수는 선언될 때 초기화되어야 함)   
만약, 오른쪽 표현식도 컴파일 타임에 평가된다면 const 변수는 컴파일 타임에 값이 평가 됨

~~~cpp
int size = 3;
int A[size] = {1, 2, 3}; // 기술적으로 가능함 (size는 동적입니다)
// 하지만 C++ 표준에서 승인 X
const int SIZE = 3;
// SIZE = 4; // 컴파일 오류 (SIZE는 const입니다)
int B[SIZE] = {1, 2, 3}; // O
const int size2 = size;
int C[size2] = {1, 2, 3}; // Bad!! size2는 const가 X
// (일부 컴파일러는 변수 크기의 스택 배열을 허용 -> 위험!)
~~~

## const 키워드와 포인터

int* : int를 가리키는 포인터
- 포인터의 값은 수정 가능 (= 포인터 변수가 다른 메모리 주소를 가리킬 수 있음)
- 포인터가 참조하는 요소를 수정할 수 있음

~~~cpp
int x = 5;
int* ptr = &x; // 포인터의 값과 포인터가 참조하는 요소 모두 수정 가능
*ptr = 10;     // x의 값이 10으로 변경됨
~~~

const int* : const int를 가리키는 포인터 (const int)*로 읽음
- 포인터의 값은 수정 가능
- 포인터가 참조하는 요소 수정 불가

~~~cpp
const int y = 8;
const int* cptr = &y;  // 포인터의 값은 수정 가능하지만, 포인터가 참조하는 요소는 수정 불가능
// *cptr = 12;         // 오류 발생: y는 상수이므로 수정할 수 없음
~~~

int *const : int를 가리키는 const 포인터
- 포인터의 값은 수정 불가
- 포인터가 참조하는 요소 수정 가능

~~~cpp
int z = 15;
int* const cptr2 = &z; // 포인터의 값은 수정 불가능하지만, 포인터가 참조하는 요소는 수정 가능
*cptr2 = 20;            // z의 값이 20으로 변경됨
// cptr2 = nullptr;    // 오류 발생: 포인터의 값은 이미 고정되어 있음
~~~

const int *const : const int를 가리키는 const 포인터
- 포인터의 값은 수정 불가
- 포인터가 참조하는 요소 수정 불가

~~~cpp
const int w = 30;
const int* const cptr3 = &w; // 포인터의 값과 포인터가 참조하는 요소 모두 수정 불가능
// *cptr3 = 40;               // 오류 발생: w는 상수이므로 수정할 수 없음
// cptr3 = nullptr;           // 오류 발생: 포인터의 값은 이미 고정되어 있음
~~~

*포인터 타입은 오른쪽에서 왼쪽으로 읽어야 함
