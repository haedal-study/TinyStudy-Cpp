# [Pointer Operations]

포인터
  - 포인터 t*은 메모리의 위치를 가리키는 값

포인터 간접 참조
  - 포인터가 가리키는 위치에 저장된 값을 얻는 것을 의미함

첨자 연산자[]
  - 주어진 위치에 있는 포인터 요소에 접근할 수 있게 함

포인터의 유형 (ex. void)은 기본 아키텍처에 따라 32비트 또는 64비트의 부호 없는 정수임
  - 연산자 +, -ㅣ ++, -- / 비교 ==, !=, <, <=, >, >= / 첨자 [] 및 간접 참조 *를 지원함
  - 포인터는 명시적으로 정수 형식으로 변환될 수 있음

해제 참조
~~~cpp
int* ptr1 = new int;
*ptr1 = 4; // 해제 참조 (할당)
int a = *ptr1; // 해제 참조 (값 가져오기)
~~~

배열 인덱싱
~~~cpp
int* ptr2 = new int[10];
ptr2[2] = 3;
int var = ptr2[4];
~~~

일반적인 오류
~~~cpp
int *ptr1, ptr2; // 하나는 포인터, 하나는 정수형 변수
int *ptr1, *ptr2; // 두 개 모두 포인터
~~~

## 포인터 변환

- 어떤 포인터 유형이든지 void*으로 암시적으로 변환될 수 있음
~~~cpp
int* ptr1 = ...;
void* ptr2 = ptr1; // int* -> void*, 암시적 변환
~~~
- void*이 아닌 포인터는 명시적으로 변환해야 함
~~~cpp
void* ptr3 = ...;
int* ptr4 = (int*) ptr3; // void* -> int*, 명시적 변환 필요
~~~
- 안전성 이유로 static cast는 void*을 제외한 포인터 변환을 허용하지 않음
~~~cpp
int* ptr5 = ...;
char* ptr6 = (char*) ptr5; // int* -> char*, 명시적 변환 필요, static_cast 허용 안됨, 위험
~~~

## 포인터 산술

배열 인덱싱의 의미   
  - ptr[i]는 *(ptr + i)와 동일함   
  - 참고) 배열 인덱싱은 음수 값을 포함하여도 수용함

포인터 산술 규칙
  - address(ptr + i) = address(ptr) + (sizeof(T) * i)   
  - 여기서 T는 ptr이 가리키는 요소의 유형

~~~cpp
int array[4] = {1, 2, 3, 4};
cout << array[1]; // 2 출력
cout << *(array + 1); // 2 출력
cout << array; // 0xFFFAFFF2 출력
cout << array + 1; // 0xFFFAFFF6 출력
int* ptr = array + 2;
cout << ptr[-1]; // 2 출력
~~~

정의되지 않은 동작   
- 포인터가 버퍼의 시작 위치보다 커져서 발생하는 포인터 오버플로우
