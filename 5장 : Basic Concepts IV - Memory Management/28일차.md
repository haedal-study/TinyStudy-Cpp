# [Structure Initialization | Dynamic Memory Initialization]

## 구조체 초기화

구조체는 집합체 유형이며 **중괄호 초기화 구문**을 사용하여 초기화할 수 있음

- 구조체 데이터 멤버를 초기화하는 여러가지 방법
	- NSDMI (Non-Static Data Member Initialization)
		구조체의 비정적 멤버 변수에 기본 값을 지정하여 초기화함
		이 방법은 C++11부터 지원되는 표준 방법임

    	- 등호 초기화
    		- 구조체의 멤버 변수에 직접 값을 할당함
    		- 이 방법은 C++03 이전에 사용됨
          ~~~cpp
          struct S {
          	unsigned x = 3; // 등호 초기화
          	unsigned y = 2; // 등호 초기화
          };
          ~~~
    	- 중괄호 초기화
    		- 중괄호를 사용하여 구조체의 멤버 변수를 초기화함
    		- 이 방법은 C++11부터 지원되는 표준 방법임
          ~~~cpp
          struct S {
          	unsigned x {3}; // 중괄호 초기화
          };
          ~~~
  - 지정된 초기화자 목록 (designated initializer list)
    - 지정된 초기화자 목록은 코드의 가독성을 높이는데 매우 유용할 수 있음
    - 이 방법은 C++20에서 소개되었음
    ~~~cpp
    struct S {
      int x, y, z;
    };
    
    A a1{1, 2, 3};
    A a2{.x = 1, .y = 2, .z = 3}; // 지정된 초기화자 목록
    ~~~

## 구조체 바인딩
C++17에서 도입된 기능
구조체나 튜플 등의 데이터 구조로부터 각 요소에 이름을 지정하여 값을 바로 추출할 수 있게 해줌

- Case 1 : 구조체 사용
~~~cpp
auto [x1, y1] = a;
// 구조체 a의 각 요소를 x1과 y1에 바인딩 함
// => a의 x 요소가 x1
// => a의 y 요소가 y1

auto [x2, y2] = f();
// 함수 f()에서 반환된 구조체의 각 요소를 x2와 y2에 바인딩 함
~~~
- Case 2 : 원시 배열 사용
~~~cpp
auto [x1, y1] = a;
// 구조체 a의 각 요소를 x1과 y1에 바인딩 함
// 여기서 a는 길이가 2인 배열
// => a의 첫번째 요소가 x1
// => a의 두번째 요소가 y1
~~~
- Case 3 : 튜플 사용
~~~cpp
auto [x1, y1] = std::tuple<float, int>{3.0f, 2};
// 튜플의 각 요소를 x1과 y1에 바인딩 함
// => 튜플의 첫번째 요소가 float 형식이므로 x1
// => 튜플의 두번째 요소가 int 형식이므로 y1
~~~

## 동적 메모리 초기화
- C++03
~~~cpp
int* a1 = new int;        // 정의되지 않음
int* a2 = new int();      // 0으로 초기화, "= int()"
int* a3 = new int(4);     // 값이 4인 단일 값 할당
int* a4 = new int[4];     // 정의되지 않은 값으로 4개의 요소 할당
int* a5 = new int[4]();   // 0으로 초기화된 4개의 요소 할당, "= int()"
int* a6 = new int ; // 유효하지 않음
~~~
- C++11
~~~cpp
int* b1 = new int[4]{};      // 0으로 초기화된 4개의 요소 할당, "= int{}"
int* b2 = new int[4]{1, 2};  // 첫 번째, 두 번째 요소 설정, 나머지는 0으로 초기화
~~~
