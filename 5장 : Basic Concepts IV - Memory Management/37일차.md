# [static_cast, const_cast, reintepret_cast]

## static_cast
- 컴파일 타임에 안전한 형변환을 수행하는 C++ 캐스트 연산자
- 명시적인 타입 변환 가능
- 컴파일러가 안전한 형변환을 할 수 있는지 확인함

~~~cpp
char a[] = {1, 2, 3, 4};
int* b = (int*) a; // 가능
cout << b[0]; // 1이 아닌 67305985 출력
//int* c = static_cast<int*>(a); // 컴파일 에러, 안전하지 않은 변환
~~~

- 특징
  - 컴파일 타임에 안전한 형변환   
      => 코드가 실행될 때 형식에 대한 오류가 발생할 가능성 줄임
  - 안전하지 않은 형변환 방지   
      => 포인터 간의 형변환 또는 서로 다른 데이터 형식 간의 형변환을 안전하게 수행할 수 있음
  - 다양한 형변환 지원   
      => 기본 형식의 형변환뿐만 아니라 사용자 정의 타입에 대한 형변환도 가능함
  - 상속 관계에서의 다형성 지원   
      => 기본 클래스와 파생 클래스 간의 포인터 또는 참조 형변환을 안전하게 수행할 수 있음

## const_cast
- constness나 volatile성을 추가하거나 제거할 수 있음
- 주로 함수의 매개변수가 const로 선언되어 있어서 해당 매개변수를 변경하고자 할 때 유용하게 활용됨

~~~cpp
const int a = 5;
const_cast<int>(a) = 3; // 가능하지만, 정의되지 않은 동작
~~~

- **const_cast를 사용하여 변수 또는 포인터의 constness를 추가하거나 제거할 수 있음   
  => const변수를 non-const로 캐스팅하거나 non-const 변수를 const로 캐스팅할 수 있음   
- **const_cast는 constness만 변경할 뿐, 변수의 실제 값이 변경되지는 않음   
  => cosnt_cast를 사용하여 const 변수를 non-const로 캐스팅하더라도 해당 변수를 통해 값을 수정하는 것은 정의되지 않은 동작을 초래할 수 있음

## reinterpret_cast
- 한 유형의 포인터를 다른 유형의 포인터로 캐스팅할 때 사용됨
- 메모리에 있는 비트를 해석하고 새로운 유형으로 다시 해석함
  => 이 연산자는 일반적으로 서로 관련이 없는 두 유형 사이에 캐스팅할 때 사용됨

- reinterpret_cast<T*>(v)는 (T*)v와 동일함
- reinterpret_cast<T&>(v)는 ((T)&v)와 동일함

~~~cpp
float b = 3.0f;
// b의 비트 표현: 01000000010000000000000000000000
int c = reinterpret_cast<int&>(b);
// c의 비트 표현: 01000000010000000000000000000000
~~~


**const_cast와 reinterpret_cast는 CPU 명령으로 컴파일되지 않음**
