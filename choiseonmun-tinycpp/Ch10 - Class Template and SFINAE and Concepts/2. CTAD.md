# 메모
## 개요
- Constructor Template Automatic Deduction
- C++17부터 제공
```cpp
template <typename T, typename R>
struct A
{
	A(T x, R y) {}
};

A<int, float> a1(3, 4.0f); // C++17
A a2(3, 4.0f); // C++17
```
- 템플릿 추론 가이드를 컴파일러에게 제공할 수도 있다.
```cpp
#1 기본
template <typename T>
struct is_string : std::false_type { };

template <>
struct is_string<string> : std::true_type { };

template <typename T>
struct MyString
{
	MyString(T)
	{
		if constexpr (is_string<T>::value)
		{
			cout << "string!";
		}
		else
		{
			cout << "Not string!";
		}
	}
};

// 생성자                  클래스 인스턴스화
MyString(const char*) -> MyString<string>;

MyString s{ "abc" }; // print "string!"

#2 Aggregate 타입
template <typename T>
struct A { T x, y; };

template <typename T>
A(T, T) -> A<T>; // C++20부터는 필요없다.

A a{1, 3}; // A<int>

#3. 독립적인 인수
template <int N>
struct A
{
	template <typename T>
	A(T) { }
};

template <typename T>
A(T) -> A<sizeof(T)>;

A a{1}; // A<4>

#4. 별칭 템플릿 추론(C++20)
template <typename T>
struct A
{
	A(T) { }
};

template <typename T>
A(T) -> A<int>;

template <typename T>
using B = A<T>;

B c{3.0}; // A<int>
```
- 클래스 내부에서는 동작하지 않는다.
```cpp
template <typename T>
struct MyString
{
	MyString(T) { }
	MyString f() { return MyString("abc"); } // MyString<const char*>
};

MyString(const char*) -> MyString<string>;

// 팩토리로 이 문제를 회피한다.
template <typename T>
auto make_my_string(const T& x) { return MyString(x); }
```
# 참고자료
- https://en.cppreference.com/w/cpp/language/class_template_argument_deduction