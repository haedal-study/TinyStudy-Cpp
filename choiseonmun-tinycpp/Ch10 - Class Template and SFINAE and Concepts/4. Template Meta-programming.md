# 메모
## 개요
- 템플릿 메타프로그래밍은 컴파일 시간에 연산을 수행하는 것이다.
- 재귀함수처럼 작성하면 된다.

## 특징
- 컴파일 시간에 연산이 이뤄지기 때문에 실행이 빠르다.
	- 하지만 그만큼 오랜 컴파일 시간을 소요한다.
- 튜링 완전성을 갖고 있다.
- 복잡하다.

## 예시1 - 팩토리얼
```cpp
template <int N>
struct Factorial {
	static constexpr int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
	static constexpr int value = 1;
};

constexpr int x = Factorial<5>::value;
```

- C++14부터는 `constexpr`을 이용해 더 쉽게 작성할 수 있다.
	- 덜 복잡하고, 디버깅도 쉬우며
	- 재귀가 없기 때문에 컴파일 시간도 빠르고
	- 다른 타입에 대해서도 동작하며
	- 실행 시간 및 컴파일 시간에 수행될 수 있다.
```cpp
template <typename T>
constexpr int factorial(T value)
{
	T temp = 1;
	for (int i = 2; i <= value; ++i)
		temp *= i;
	return temp;
}
```

## 예시 2 - 로그2
```cpp
template <int N>
struct Log2
{
	static_assert(N > 0, "N must be greater than zero");

	static constexpr int value = 1 + Log2<N / 2>::value;
};

template <>
struct Log2<1>
{
	static constexpr int value = 0;
};
```

## 예시 3 - 로그
```cpp
template <int A, int B>
struct Max {
	static constexpr int value = A > B ? A : B;
};

template <int N, int BASE>
struct Log
{
	static_assert(N > 0, "N must be greater than zero");
	static_assert(BASE > 0 "Base must be greater than zero");

	static constexpr int Temp = Max<1, N / BASE>::value;
	static constexpr int value = 1 + Log<Temp, BASE>::value;
};

template <int BASE>
struct Log<1, BASE>
{
	static constexpr int value = 0;
};
```

## 예시 4 - Unroll
- Compile-time / Run-time MIX
```cpp
template <int UnrollCount, int Step = 0>
struct Unroll
{
	template <typename Op>
	static void Run(Op op) {
		op(Step); // 실행 시간
		Unroll<UnrollCount, Step + 1>::Run(op);	
	}
};

template <int UnrollCount>
struct Unroll<UnrollCount, UnrollCount>
{
	template <typename Op>
	static void Run(Op) {}
};

auto lambda = [](int step) { cout << step << ", "; };
Unroll<5>::Run(lambda); // "0, 1, 2, 3, 4"
```

