# 메모

## 클래스와 함수
- 아래와 같은 경우 2가지 방법으로 특수화를 할 수 있다.
	- Generic class + Generic function
	- Full class specialization + generic/full specialization function
```cpp
template <typename T, typename R>
struct A
{
	template <typename X, typename Y>
	void f();
};
```

## typename
- 템플릿 내부에서 컴파일러에게 해당 기호가 타입임을 알려주기 위해 사용한다.

## Dependent names
- 템플릿 내부에서 이름을 컴파일러에게 알려주기 위하여 `template`을 사용한다.
	- 단, 일부 최신 컴파일러는 필요하지 않다.
```cpp
template <typename T>
struct A
{
	template <typename R>
	void g() { }
};

template <typename T> // A<T> is a dependent name
void f(A<T> a) {
	a.g<int>(); // ! g<int> is a dependent name
				// interpreted as: "(a.g < int) > ()"
	a.template g<int>(); // ok
}
```

## 클래스 템플릿 하이어라키와 using
- 부모 클래스의 멤버를 내부적으로 사용하려면 `using` 선언이 필요하다.
```cpp
template <typename T>
struct A
{
	T x;
	void f() { }
};

template <typename T>
struct B : A<T> {
	using A<T>::x; // 없으면 새로운 특수화가 될 수도 있다.
	using A<T>::f;

	void g() {
		f(); // using이 없으면 this->f() 식으로 해야 한다.
		x;
	}
}
```
## 가상 함수와 템플릿
- 가상 함수는 템플릿 인수를 가질 수 없다.

## Template template parameter
- 특정 타입이 아닌 템플릿을 매칭한다.
```cpp
template <typename T> struct A {};

template <template<typename> class R>
struct B
{
	R<int> x;
	R<float> y;
};

// C++17부터는 class 키워드 대신 typename으로 쓸 수 있다.
template <template<typename> class R, typename S>
void f(R<S> x);
```
# 참고자료
- https://stackoverflow.com/questions/7968023/c-virtual-template-method/7968213#7968213
- https://en.cppreference.com/w/cpp/language/template_parameters#Template_template_parameter
- https://en.cppreference.com/w/cpp/language/using_declaration
- https://en.cppreference.com/w/cpp/language/dependent_name
- https://en.cppreference.com/w/cpp/keyword/typename