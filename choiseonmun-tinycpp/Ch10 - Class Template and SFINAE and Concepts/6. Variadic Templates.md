# 메모
# 개요
- 문법
```cpp
template <typename... TArgs> // Variadic typename -> parameter pack
void f(TArgs... args) // Pack expansion -> pattern
{
	int values[] = { args... }; // Arguments expansion
}
```
- `sizeof...` 연산자로 인수 팩의 갯수를 알 수 있다.
```cpp
sizeof...(args);
```
- 제네릭 파라미터(since C++14)가 있는 람다에 적용할 수 있다.
```cpp
auto lambda = [](auto... args) { };
```
- `concept`에도 적용할 수 있다.(since C++20)
```cpp
void f(std::floating_point auto... args) { }
```
- 캡쳐, 생성자 초기자 목록, using 선언에도 사용할 수 있다.
```cpp
template <typename... BaseClasses>
struct A : BaseClasses... { // : BaseClass1, BaseClass2...
	A(int v) : BaseClasses...{v} { } // BaseClass1{v}, BaseClass2{v}, ...

	using BaseClasses::f;
	// using BaseClass1::f;
	// using BaseClass2::f;
};

void f(auto... args) {
	auto lambda = [args&...](){}; // capture by reference
}
```

## 함수 초기화 방법
```cpp
#1 pass by value
template <typename... TArgs>
void f(TArgs... args) { }

#2 pass by const reference
template <typename... TArgs>
void g(const TArgs&... args) { }

#3 pass by pointer
template <typename... TArgs>
void h(TArgs*... args) { }

#4 pass a list of array references
template <int... Sizes>
void l(int (&...arrays)[Sizes]) { }
```

## 예시
- 1번
```cpp
// Base Case
template <typename T, typename R>
auto add(T a, R b)
{
	return a + b;
}

// Recursive Case
template <typename T, typename... TArgs>
auto add(T a, TArgs... args)
{	
	return a + add(args...);
}

// 2 + add(3.0, 4, 5)
// 2 + 3.0 + add(4, 5)
add(2, 3.0, 4, 5);

add(2); // compiler error
```

- 2번
```cpp
struct A
{
	int v;
	int f() { return v; }
};

template <typename... TArgs>
int f(TArgs... args)
{
	return add(args.f()...);
}

// add(A{1}.f(), A{2}.f(), A{3}.f())
f(A{1}, A{2}, A{3});
```

- 3번
```cpp
template <typename T>
T square(T value) { return value * value; }

template <typename... TArgs>
auto add_square(TArgs... args)
{
	return add(square(args)...);
}

// add(square(2), square(2), square(3.0));
add_square(2, 2, 3.0);
```

- 4번
```cpp
template <typename... TArgs>
int g(TArgs... args) { }

template <typename... TArgs>
int f(TArgs... args)
{
	g<std::make_unsigned_t<TArgs>...>(args...);
}

// g<unsigned, unsigned, unsigned>(1, 2, 3);
f(1, 2, 3);
```

## Folding Expression
- C++17부터 지원
- 이항 연산자의 피연산자로 파라미터 팩을 지원한다.
```cpp
template <typename... Args>
auto add_unary(Args... args) {
	return (... + args);
}

// return (1 + 2.0f + 3LL);
add_unary(1, 2.0f, 3LL); // 6.0f

template <typename... Args>
auto add_binary(Args... args) {
	return (1 + ... + args);
}

// return (1 + 1 + 2.0f + 3LL);
add_binary(1, 2.0f, 3LL); // 7.0f
```

- 예시 1번
```cpp
template <typename... TArgs>
int f(TArgs... args) {
	return (args, ...); // same as (..., args)
}

// return (1, 2, 3);
f(1, 2, 3); // 3
```

- 예시 2번
```cpp
template <typename T>
T square(T value) { return value * value; }

template <typename... TArgs>
auto add_square(TArgs... args) {
	return (square(args) + ...);
}

// return (square(2) + square(2) + square(3.0f));
add_square(2, 2, 3.0f); // 17.0f
```

## 가변 클래스 템플릿
- 재귀적인 자료 구조를 만드는 데 사용할 수 있다.
```cpp
#1 Add
// declaration
template <int... NArgs>
struct Add;

// base case
template <int N1, int N2>
struct Add<N1, N2> {
	static constexpr int value = N1 + N2;
};

// recursive case
template <int N1, int... NArgs>
struct Add<N1, NArgs...> {
	static constexpr int value = N1 + Add<NArgs...>::value;
};

// 2 + Add<3, 4>::value
//     3 + 4    
Add<2, 3, 4>::value;
Add<>; // ! no match
Add<2>::value; // ! 2 + Add<>

#2 Tuple
template <typename... TArgs>
struct Tuple;

template <typename T>
struct Tuple<T> {
	T value;
};

template <typename T, typename... TArgs>
struct Tuple<T, TArgs...> {
	T value;
	Tuple<TArgs...> tail;
};

Tuple<int, float, char> t1 { 2, 2.0, 'a' };
t1.value; // 2
t1.tail.value; // 2.0
t1.tail.tail.value; // 'a'


#3 함수 애리티(인수의 개수)를 컴파일 시간에 얻기
template <typename T>
struct GetArity : GetArity<decltype(&T::operator())> { };

// Generic Function Pointer
template <typename R, typename... Args>
struct GetArity<R(*)(Args...)> {
	static constexpr int value = sizeof...(Args);
};

// Generic Function Reference
template <typename R, typename... Args>
struct GetArity<R(&)(Args...)> {
	static constexpr int value = sizeof...(Args);
};

// Generic Function Object
template <typename R, typename... Args>
struct GetArity<R(Args...)> {
	static constexpr int value = sizeof...(Args);
};
// Class Member
template <typename R, typename C, typename... Args>
struct GetArity<R(C::*)(Args...)> {
	static constexpr int value = sizeof...(Args);
};

// const Class Member
template <typename R, typename C, typename... Args>
struct GetArity<R(C::*)(Args...) const> {
	static constexpr int value = sizeof...(Args);
};

void f(int, char, double) { }
int main()
{
	// function object
	GetArity<decltype(f)>::value; // 3

	// function reference
	auto& g = f;
	GetArity<decltype(g)>::value;

	// function reference
	GetArity<decltype((f))>::value;

	// function pointer
	auto* h = f;
	GetArity<decltype(h)>::value;

	// class member
	GetArity<Test>::value;
	GetArity<const Test>::value;
	
	// lambda
	auto lambda = [](char, char, char) {};
	GetArity<decltype(lambda)>::value;

	// std::function
	std::function<void(char, char, char)> f2 = lambda;
	GetArity<decltype(f2)>::value;
}
```

asdasd

# 참고자료
- https://en.cppreference.com/w/cpp/language/parameter_pack
- https://www.scs.stanford.edu/~dm/blog/param-pack.html
- https://stackoverflow.com/questions/27866909/get-function-arity-from-template-parameter/27867127#27867127