# 메모
## 개요
- Substitution Failure Is Not An Error
- 함수 템플릿의 오버로드를 해석할 때 적용된다. 특수화 실패 시 컴파일 오류를 일으키는 것이 아니라 해당 버전을 버리는 것(discard)을 의미한다.

## 예시
- SFINAE를 적용하는 공용적인 방법은 `std::enable_if`를 이용하는 것이다.
	- 조건이 `false`라면 오류 타입이 된다.
```cpp
#1. 반환 타입에 활용하기
template <typename T>
std::enable_if_t<std::is_signed_v<T>>
f(T) { cout << "signed"; }

template <typename T>
std::enable_if_t<false == std::is_signed_v<T>>
f(T) { cout << "unsigned"; }

#2. 파라미터에 활용하기
template <typename T>
void f(std::enable_if_t<std::is_signed_v<T>, T>) { cout << "signed"; }

template <typename T>
void f(T,
	  std::enable_if_t<std::is_signed_v<T>, int> = 0)
{
	cout << "signed";
}

#3. 템플릿 파라미터에 활용하기
template <typename T, std::enable_if_t<std::is_signed_v<T>, int> = 0>
void f(T) { }


#4. 클래스 SFINAE
template <typename T, typename Enable = void>
struct A;

template <typename T>
struct A<T, std::enable_if_t<std::is_signed_v<T>>> { };

template <typename T>
struct A<T, std::enable_if_t<false == std::is_signed_v<T>>> { };
```

- 구조체 멤버를 확인하는 데도 사용할 수 있다.
```cpp
struct A {
	static int x;
	int y;
	using type = int;
};

struct B { };

template <typename T, typename = void>
struct has_x : std::false_type {};

template <typename T>
struct has_x<T, decltype((void)T::x)> : std::true_type { };

template <typename T, typename = void>
struct has_y : std::false_type {};

// decltype 식 안에 멤버 함수를 전달할 때는
// std::declval을 사용한다.
template <typename T>
struct has_y<T, decltype((void)std::declval<T>().y)> : std::true_type {};

template <typename T, typename = void>
struct has_type : std::false_type { };

template <typename T>
struct has_type<T, std::void_t<typename T::type>> : std::true_type { };
```
- 연산자를 지원하는지 확인하는 데도 사용할 수 있다.
```cpp
template <typename T>
using can_output_to_stream_t = decltype(std::declval<std::ostream&>() << std::declval<T>());

template <typename T, typename = void>
struct is_stream_supported : std::false_type { };

template <typename T>
struct is_stream_supported<T, can_output_to_stream_t<T>> : std::true_type { };

struct A { };

is_stream_supported<int>::value; // true
is_stream_supported<A>::value; // false
```

## 잘못 적용한 예시
- 같은 시그니처에 대한 재정의를 하면 안된다.
```cpp
template <typename T, typename = std::enable_if_t<std::is_signed_v<T>>
void f(T) { }

// ! 같은 시그니처에 대한 재정의이므로 컴파일 오류
template <typename T, typename = std::enable_if_t<false== std::is_signed_v<T>>
void f(T) { }
```

- `auto`를 사용할 수 없다.
```cpp
// ! auto는 여기서 허용되지 않는다.
template <typename T>
std::enable_if_t<std::is_signed_v<T>, auto> f(T) { }
```
# 참고자료
- https://en.cppreference.com/w/cpp/language/sfinae