# 메모
## 개요
- C++20부터 지원
- 템플릿 인수에 대한 제약조건을 명시하며, 컴파일 시간에 수행한다.
- `std::enable_if`와 비교하여...
	- 읽고 쓰기가 쉽다.
	- 명확한 오류 메시지를 출력한다.
	- 컴파일 시간이 빠르다.

## Concept
- 문법
```cpp
[template arguments]
concept [name] = [compile-time boolean expression];
```

- 예시
```cpp
template <typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

// #1 템플릿 인수 제약조건으로 사용할 수 있다.
template <Arithmetic T>
T add(T lhs, T rhs) {
	return lhs + rhs;
}

// #2. auto 추론 제약조건으로 사용할 수 있다.
auto add(Arithmetic auto lhs, Arithmetic auto rhs)
{
	return lhs + rhs;
}
```

## requires 절
- 문법
```cpp
requires [compile-time boolean expression or Concept]
```

- 예시
```cpp
#1. 템플릿 파라미터 목록 이후에
template <typename T> requires Arithmetic<T>
T add(T lhs, T rhs)
{
	return lhs + rhs;
}

#2. 함수 선언 이후에
template <typename T>
T add(T lhs, T rhs) requires (sizeof(T) >= 4) {
	return lhs + rhs;
}

#3. conecept과 함께 쓸 수도 있다.
template <Arithmetic T> requires (sizeof(T) >= 4)
T add(T lhs, T rhs);
```

## requires 식
- 문법
```cpp
requires [(arguments)] {
	[SFINAE contrain]; // or
	requires [predicate];
} -> bool
```

- 예시
```cpp
#1. SFINAE 제약조건
template <typename T>
concept MyConcept = requires (T a, T b) {
	a + b;  // Req. 1 - + 연산자 지원
	a[0];   // Req. 2 - [] 연산자 지원
	a.x;    // Req. 3 - "x" 데이터 멤버 가지고 있어야 함.
	a.f();  // Req. 4 - "f" 함수 멤버 가지고 있어야 함.
	typename T::type; // Req. 5 - "type" 필드 있어야 함.
};

#2. concept 라이브러리
template <typename T>
concept MyConcept2 = requires (T a, T b) {
	// Req. 6
	// 역참조 지원, 정수와 더한 값이 float로 변환될 수 있어야 함
	{*a + 1} -> std::convertible_to<float>;

	// Req. 7
	// a * a가 유효해야 함, 그 결과 타입이 int여야 함.
	{a * a} -> std::same_as<int>;
};

#3. requires 절과 함께 사용할 수 있다.
template <typename T>
concept Arithmetic = requires {
	T::value;
	requires std::is_arithmetic_v<T>;
};

template <typename T>
void f(T a) requires requires { T::value; }
{ }

#4. constexpr와 함께 사용할 수 있다.
constexpr bool has_member_x = requires(T v) { v.x; };

if constexpr (MyConcept<T>)

static_assert(requires(T v){ ++v; }, "No Increment");

template <typename Iter>
constexpr bool is_iterator() {
	return requires(Iter it) { *it++; };
}

#5 Nested requires
requires(Iter v) { // expression -> bool
	Iter it;
	requires requires(typename Iter::value_type v) {
		v = *it; // read
		*it = v; // write
	}
}
```
# 참고자료
- https://en.cppreference.com/w/cpp/language/constraints
- https://en.cppreference.com/w/cpp/concepts
- https://en.cppreference.com/w/cpp/header/concepts
- https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations
- https://en.cppreference.com/w/cpp/language/requires