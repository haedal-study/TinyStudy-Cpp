# 메모
## 개요
- 전처리기가 필요한 상황은 아래와 같다. 이 외에는 `const` 혹은 `constexpr`을 사용하는 것을 권장한다.
	- 조건부 컴파일
	- 다른 언어(e.g. 어셈블리)와 섞어 사용할 때
	- 복잡한 이름을 대체할 때

## 매크로
- `#define` / `#undef`
- 매크로는 과하게 사용하면 안된다.
	- 직접적으로 디버깅 X
	- 예측 불가능한 사이드 이펙트
	- 이름 공간 및 범위 X
- 연산자
	- 문자열화 연산자(`#`, Stringizing Operator)
		- 문자열 리터럴로 만듦
	- - 토큰 결합 연산자(`##`, Token-Pasting Operator)
		- 두 개의 토큰을 합침
```cpp
#define STRING_MACRO(string) #string
cout << STRING_MACRO(hello); // "hello"

#define FUNC_GEN_A(tokenA, tokenB) \ 
	void tokenA##tokenB() {}

FUNC_GEN_A(my, function) // myfunction()
```
- 가변 매크로(C++11)
```cpp
#define SOMETHING(...) \ 
	f(__VA_ARGS__);
```
- Source Location Macro
	- - `__LINE__`
	- `__FILE__`
	- `__func__`(C++11)
	- C++20부터는 `<source_location>`에 매크로 대신 사용할 수 있는 라이브러리 제공
		- `current()`
		- `line()`
		- `column()`
		- `file_name()`
		- `function_name()`
```cpp
#include <source_location>

void foo(std::source_location s = std::source_location::current())
{
	print("function: {}, line : {}", s.function_name(), s.line());
}
```

- 기타 매크로
	- `__DATE__`
	- `__TIME__`
- Feature Testing Macro
	- `__has_include`(C++17) : 헤더 파일 지원 여부 확인
	- [C++20부터 컴파일러가 언어의 기능을 지원하는지 확인할 수 있는 매크로 제공](https://en.cppreference.com/w/cpp/feature_test)
- 매크로를 이용한 간단한 트릭
	- 숫자 리터럴을 문자열 리터럴로 변환
```cpp
#define TO_LITERAL_AUX(x) #x
#define TO_LITERAL(x)  TO_LITERAL_AUX(x)
```

## 조건부 컴파일
- 종류
	- `#if`, `#elif`, `#else`, `#endif`
	- `#if defined | #ifdef`, `#elif defined | #elifdef`(C++23)
	- `#if !defined | #ifndef`, `#elif !defined | #leifndef`(C++23)
- 헬퍼 매크로
	- C++ 버전
		- `__cplusplus` : C++ 버전
	- 컴파일러
		- `__GNUG__` : gcc/g++
		- `__clang__` : clang/clang++
		- `_MSC_VER` : MSVC
	- 운영체제
		- `_WIN64` : Windows 64bit
		- `__linux__` : Linux
		- `__APPLE__` : MacOS
		- `__MINGW32__` : MinGW 32
# `#error`, `#warning`
- `#error`
	- 컴파일 시 중단하고 메시지 출력
- `#warning`(C++23)
	- 컴파일 시 경고 메시지 출력

# `#pragma`
- 구현체 특정 기능으로 이식성이 없다.
- `#pragma message "text"`
	- 컴파일 시간에 메시지 출력
- `_Pragma(<command>)`(C++11)
	- 매크로 정의에 `pragma` 임베드
```cpp
#define MY_MESSAGE _Pragma("message(\"hello\")")
```

# 전처리기 사용 시 주로 겪는 오류
- 헤더 파일 포함하기 전 매크로를 정의하면 의도치 않은 오류를 초래할 수 있다.
-  `#if defined` 사용 시 매크로 가시성과 연관된 버그가 발생할 수 있다.
```cpp
// 매크로가 정의되어 있을지 없을지 모른다.
#if ENABLE_DEBUG
	void f(int v) { cout << v << endl; return v + 3; }
#else
	void f(int v) { return v * 3; }
#endif
```
- 매크로 정의부에 괄호를 빼먹으면 의도한 것과 다르게 평가될 수 있다.
- 매크로는 식의 평가와 관련된 버그를 야기시킨다.
```cpp
#if defined (DEBUG)
#define CHECK(EXPR) // do something with EXPR
void check(bool b) { /*do something with b */ }
#else
#define CHECK(EXPR) // do nothing
void check(bool b) {} // do nothing
#endif

bool f() { /* return a boolean value */ }

check(f());
CHECK(f()); // DEBUG가 정의되어 있지 않았을 때 여기 있는 f()는
			// 평가되지 않는다.
```
- 여러 줄의 매크로 정의에서 중괄호를 빼먹는 것을 주의한다.
- 매크로는 범위가 없다.
- 매크로는 사이드 이펙트가 있다.
```cpp
#define MIN(a, b) ((a) < (b) ? (a) : (b))

int main()
{
	int arr1[] = { 1, 5, 2 };
	int arr2[] = { 6, 3, 4 };
	int i = 0;
	int j = 0;
	int v1 = MIN(arr1[i++], arr2[j++]); // v1 = 5
}
```
- 매크로는 그 자체로 미정의된 동작을 가질 수 있다.
```cpp
#define MY_MACRO defined(EXTERNAL_MACRO)

#if MY_MACRO
#define MY_VALUE 1
#else
#define MY_VALUE 0
#endif

int f() { return MY_VALUE; } // Undefined Behaviour
```
- 매크로는 환경과 컴파일러에 의존한다.
- 코드 주입을 주의해야 한다.
```cpp
#define CHECK_ERROR(condition)  { \
	if (condition) { \
		std::printf("expr : " #condition " failed at line %d\n", \
			__LINE__); \
	} \
}

int t = 6, s = 3;
CHECK_ERROR(t > s); // print "expr: t > s failed at line 13"
CHECK_ERROR(t % s == 0); // segfalut
				// printf interprets "% s" as a format specifier
```
# 참고자료
- https://en.cppreference.com/w/cpp/preprocessor
- https://sourceforge.net/p/predef/wiki/Home/
- http://nadeausoftware.com/articles/2012/01/c_c_tip_how_use_compiler_predefined_macros_detect_operating_system
- https://abseil.io/docs/cpp/platforms/macros
- https://arne-mertz.de/2019/03/macro-evil/