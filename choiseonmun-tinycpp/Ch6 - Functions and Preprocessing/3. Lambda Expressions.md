# 메모
## 개요
- inline local-scope function object
- 문법
```cpp
// = 오른쪽의 식을 람다 표현식(Lambda Expression)이라 한다.
// 람다 표현식으로 생성된 객체를 클로저(Closure)라 한다.
auto x = [capture clause] (parameters) { body };
```
- 람다는 값 캡처 시 기본적으로 `const`다. 따라서 값을 수정하고 싶다면 `mutable` 키워드를 사용한다.
```cpp
int var = 1;
auto lambda = [=]() { var = 3; }; // Compile Error

auto lambda2 = [=]() mutable { var = 3; }; // OK
lambda2();
```
- 람다 표현식끼리 합성할 수 있다.
```cpp
auto lambda1 = [](int value) { return value + 4; };
auto lambda2 = [](int value) { return value * 2; };

auto lambda3 = [&](int value) { return lambda2(lambda1(value)); };
```
- 람다를 반환할 수 있다.
	- 이를 이용해 동적 디스패치를 할 수 있다.
```cpp
#include <functional>
#include <cstdlib>

using namespace std;  

auto f() -> 
auto f() { return [](int lhs, int rhs) { return lhs < rhs; }; }
auto g() { return [](int lhs, int rhs) { return lhs > rhs; }; }

int main()
{
    auto lambda = (rand() % 2 == 1) ? f() : g();
    array<int, 5> arr = { 5, 3, 2, 4, 1 };

    sort(arr.begin(), arr.end(), lambda);

}
```
- C++14부터는 파라미터의 타입을 자동으로 추론하거나, 초기화할 수 있다.
```cpp
auto x = [](auto value = 10) { return value + 4; }
```
- C++17부터는 `constexpr`을 지원한다. 그리고 C++20부터는 `consteval`을 지원한다.
```cpp
auto factorial = [](int value) constexpr {
	int ret = 1;
	for (int i = 2; i <= value; ++i)
		ret *= i;

	return ret;
};

auto mul = [](int v) consteval { return v * 2; };

constexpr int v1 = factorial(4) + mul(5);
```
- C++20부터는 `template`과 `requires`를 지원한다.
```cpp
auto lambda = []<typename T>(T value)
				requires std::is_arithmetic_v<T> {
		return value * 2;
};

auto v = lambda(2.4); // 4.8
```
- C++23부터는 람다에도 `[[nodiscard]]`를 적용할 수 있다.
```cpp
auto lambda = [] [[nodiscard]] { return 3; };
lambda(); // Warning
```

## 캡처 리스트
- 값 혹은 레퍼런스로 캡처할 수 있다.
	- 레퍼런스로 캡처하고 싶으면 `&`을 붙인다.
- 콤마로 여러 개를 캡처할 수 있다.
- `constexpr` 변수는 캡쳐하지 않아도 사용할 수 있다.
```cpp
constexpr int LIMIT = 10;
array<int, 5> arr = { 10, 12, 5, 7, 3 };

cout << all_of(arr.begin(), arr.end(), [](auto elem) { return elem >= LIMIT; });
```
- 클래스에서는..
	- `[this]` : 인스턴스를 레퍼런스로 캡처한다.(implicit in C++17)
	- `[x = x]` : 인스턴스 멤버 `x`를 값으로 캡처한다.(C++14)
	- `[&x = x]` : 인스턴스 멤버 `x`를 레퍼런스로 캡처한다.(C++14)
	- `[=]` : C++20부터는 `this`를 자동으로 캡처하지 않는다.
```cpp
class A
{
	int data = 1;

	void f() {
		int var = 2;
		// copy by-value, return 2
		auto lambda1 = [=]() { return var; };
		// shadowing, return 3
		auto lambda2 = [=]() { int var = 3; return var; };
		// copy by-reference, return 1
		auto lambda3 = [this]() { return data; };
		// copy by-value(C++17), return 1;
		auto lambda4 = [*this]() { return data; };
		// ! 'data' is not visible
		// auto lambda5 = [data]() { return data; };
		// copy by-value, return 1
		auto lambda6 = [data = data]() { return data; };
	}
};
```

# 참고자료
- https://en.cppreference.com/w/cpp/language/lambda