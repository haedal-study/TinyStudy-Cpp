# 메모
## 개요
- 일반화 프로그래밍을 위한 매커니즘
- 함수, 클래스, 변수(since C++14)에 대해서 사용 가능

## 이점
- 일반화 프로그래밍이 가능하기 때문에 코드의 재사용성이 늘어나고, 적은 코드를 작성할 수 있으며, 유지보수성이 증가한다.
- 컴파일 시간에 연산하고 최적화 하기 때문에 성능 상 이점이 있다.

## 단점
- 일반적인 C++ 코드와 다르기 때문에 가독성이 떨어지고, 오류 발생 시 암호문 같은 오류 메시지 때문에 원인 파악이 쉽지 않다.
- 컴파일 시간이 늘어나고 바이너리 크기가 증가한다.

## 템플릿 파라미터
- - 템플릿 파라미터는 이름이 없을 수 있다.
```cpp
void f() {} // always generated

template <typename = void>
void g() { }

int main() {
	g(); // generated only if it's called.
}
```
- 함수 파라미터의 기본값처럼 템플릿 파라미터에도 기본값을 줄 수 있다.(since C++11)
- 이전 값을 이용해 초기화 할 수 있다.(since C++11)
```cpp
template <int A, int B = A + 3>
void f() {
	cout << B;
}

template <typename T, int S = sizeof(T)>
void g(T) {
	cout << S;
}

f<3>(); // B = 6
g(3); // S = 4
```

## 인스턴스화
- 템플릿 파라미터 대신에 구체적인 값이나 타입으로 대체하는 것
- 암시적 혹은 명시적으로 이뤄진다.
- 명시적으로 인스턴스화를 하면 컴파일러가 자동으로 코드를 생성해내지 않기 때문에 바이너리 크기를 줄일 수 있다. 또, [의도적으로 내가 원하는 타입으로만 인스턴스화를 제한할 수도 있다.](https://stackoverflow.com/questions/2351148/explicit-template-instantiation-when-is-it-used)

## 특수화
- 특정 타입에 대해서 구체적인 구현체를 만드는 것
```cpp
template <typename T>
bool compare(T a, T b)
{
	return a < b;
}

// 부동소수점을 위한 비교 함수를 따로 만들었다.
template<>
bool compare<float>(float a, float b)
{
	// 좀 더 적합한 코드...
}
```
- 부분 특수화 혹은 전체 특수화할 수 있다.
# 참고사항
- https://en.cppreference.com/w/cpp/language/templates
- https://stackoverflow.com/questions/2351148/explicit-template-instantiation-when-is-it-used