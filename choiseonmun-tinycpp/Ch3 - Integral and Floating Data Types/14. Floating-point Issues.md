# 실수할 수 있는 부분
- 아주 큰 수는 부동 소수점보다 정수형이 정확하다.
```cpp
cout << (int)1677217.0f; // output : 16777216
```

- `float`와 `double`은 다르다.
```cpp
cout << (1.1 != 1.1f); // output : true
```

- 부동 소수점의 정확도는 유한하다.
```cpp
cout << setprecision(20) << 3.33333333f; // output : 3.333333254
```

- 부동 소수점의 산술 연산은 결합 법칙을 만족하지 않는다.
	- 연산 순서에 늘 주의한다. 연산 순서가 같으면 어떤 기계에서도 동일한 결과임을 보장한다.
```cpp
cout << 0.1 + (0.2 + 0.3) == (0.1 + 0.2) + 0.3; // output : false
```

# FMA; Fused Multiply-Add
- (GPU를 포함해) 최신 아키텍처는 단일 명령어로 덧셈과 곱셈을 계산하기 위해 FMA를 제공한다. (대부분 컴파일러에 의해 수행된다.)
- `fma(x, y, z)`의 반올림 오차는 `x * y + z`보다 작다.

# 파국적 취소(Catastrophic Cancellation) / 중요도 상실(Loss of Significance)
- 부동 소수점 계산에서 관련 정보가 신뢰할 수 없는 상태로 손실한 것
- 2가지 경우
	- 두 수를 더하거나 뺄 때, 두 수의 차이가 매우 클 경우 더 작은 값이 손실된다.
	- `a - b`에서 `a`와 `b`가 원래 값의 근삿값이고 `a ≈ b`라면, 정확도로 인해 결과의 일부분이 손실된다. 즉, 작은 절대 오차지만 큰 상대 오차가 된다.

# 부동소수점 비교
![[10. Machine Epsilon, ULP#오차]]

# 요약
- 덧셈, 뺄셈보다 **곱셈, 나눗셈**을 선호하라.
- **같은 규모의 수끼리 계산**하도록 재구성하라.
- **0을 아주 작은 수**(임계값 이하)로 두는 것을 고려하라.
- 2의 거듭제곱으로 배율하는 것은 안전하다.
- **로그 배율**로 전환하라. 곱셈이 덧셈이 되고, 나눗셈이 뺄셈이 된다.
- **보상 알고리즘**을 사용하라. (e.g. Kahan summation, Dekker's FastTwoSum, Rump's AccSum)