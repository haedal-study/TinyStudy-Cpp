### 연산자 오버로딩
- 연산자 오버로딩은 다형성의 특수한 경우라고 할수 있습니다.
- 일부 연산자를 다형성 함수로 처리하여 인자의 타입에 따라 다른 동작을 수행하게 할 수 있습니다.
```C++
// 문법은 아래와 같이 구현할 수 있습니다. 
// ReturnType operatorOp(const ParameterType& param) const {// 연산구현}};


struct Point { int x, y; Point operator+(const Point& p) 
const { return {x + p.x, y + p.y}; } };
Point a{1, 2}; 
Point b{5, 3}; 
Point c = a + b; // "c" is (6, 5)

//이렇게 가독성 망친 코드를 구성할수도 있다.

struct Point { int x, y; 

	Point& operator+=(const Point& p) {
	x = p.x;
	y = p.y;
	return *this;

	}
};
Point a{ 1, 2 };
Point b{ 5, 3 };

int main() {
	a += b;
	Point c = a; // "c" is (5, 3) 
	cout << c.x; cout << c.y;
	return 0;
}


```

### 비교연산자
- 두 객체를 비교하는데 사용되며, <, <=, == 등이 있습니다.
	-  객체간의 순서를 결정하거나 동등성을 확인하는데 사용됩니다.
-코드예시
	- std::sort함수는 `<` 연산자를 사용하여 배열을 정렬합니다. 연산자가 오버로딩 되어있으므로, 객체의 x값의 제곱을 기준으로 값이 정렬됩니다. 
	- `operator>(A a)`...로 코드를 수정하면 컴파일 에러가 발생합니다.
		- 이는 std::sort함수는 `<` 연산자를 사용하는데, 적절한 연산자를 찾지 못해, 컴파일 에러가 발생하게 됩니다.
```C++
#include <algorithm>
#include <iostream>

struct A { 
    int x; 
    bool operator<(A a) const { 
        return x * x < a.x * a.x; 
    } 
};

int main() {
    A array[] = {5, -1, 4, -7}; 
    std::sort(array, array + 4); // array: {-1, 4, 5, -7}
    
    for (const auto& a : array) {
        std::cout << a.x << " ";
    }
    return 0;
}

```


### Spaceship 연산자 (operator <=>)
- 스페이스쉽 연산자는 객체간의 비교를 단순화하고 자동화하는 비교연산자를 말합니다.
- 이 연산자를 사용하여, `<,<=,==,>=,>` 같은 연산자를 따로 정의하지 않아도 됩니다.
	- 다시말해 <=> 연산자는 위 연산자 모두를 대체가능합니다. 
```C++ 
struct A { 
	  bool operator==(const A&) const;
	  bool operator!=(const A&) const;
	  bool operator<(const A&) const;
	  bool operator<=(const A&) const;
	  bool operator>(const A&) const;
	  bool operator>=(const A&) const; }; // replaced by 
  struct B { int operator<=>(const B&) const; }; 36/63 
```

- 컴파일러는 멤버들의 default 비교의미를 사용하여, 스페이스십 연산자의 코드를 자동으로 생성할 수 있습니다.
코드예시
```C++
//예를들어, spaceship Operator를 사용하여 아래와 같은 코드를 간소화를 할 수 있습니다
struct Obj {
    int x;
    char y;
    short z[2];

    bool operator<(const Obj& other) const {
        if (x != other.x) return x < other.x;
        if (y != other.y) return y < other.y;
        if (z[0] != other.z[0]) return z[0] < other.z[0];
        return z[1] < other.z[1];
    }
};


#include <compare>
struct Obj {
    int x;
    char y;
    short z[2];

    auto operator<=>(const Obj&) const = default;
};


```
### Spaceship 연산자의 비교순서
- 스페이스쉽 연산자는 다음 세가지 비교순서를 사용합니다. 이 순서를 통해 객체를 비교할 때 엄격설과 결과의 특성을 정의합니다.
- `a <=> b`의 결과는 `std::strong_ordering`, `std::weak_ordering`, 또는 `std::partial_ordering` 타입 중 하나입니다.
	- 강한 순서(strong ordering)
		- a와 b가 동등하다면 a와 b는 같은 값을 가집니다.
		- <,`==`,> 중 하나는 반드시 참이어야 합니다.
		- `int`, `char` 타입일때 `std::strong_ordering`을 사용합니다.
	- 약한 순서(weak ordering)
		- a와 b가 동등할때, a와 b는 같은값을 가질수 없습니다
		- 다만 >,`==`,> 중 하나는 반드시 참이어야합니다.
		- 사용자 정의타입의 경우 `std::weak_ordering`을 사용합니다. 
	- 부분 순서(partial ordering)
		- a,와 b가 동들할때, a와 b는 같은 값을 가지지 않을 수 있습니다.
		- >, `==`,<가 모두 거짓일 수 있습니다
		- `float`와 `NaN`같은경우, `std::partial_ordering`을 따릅니다.
	
```C++
#include <iostream>
#include <compare>

struct Rectangle {
    int width, height;

    auto operator<=>(const Rectangle& other) const {
        return (width * height) <=> (other.width * other.height);
    }
};

int main() {
    Rectangle a{2, 5};
    Rectangle b{5, 2};

    // a와 b 비교
    auto result = a <=> b;

    if (result == std::strong_ordering::less) {
        std::cout << "a is less than b\n";
    } else if (result == std::strong_ordering::greater) {
        std::cout << "a is greater than b\n";
    } else if (result == std::strong_ordering::equal) {
        std::cout << "a is equal to b\n";
    }

    return 0;
}

```