### array subscript `operator[]`
- 배열 서브 스크립트 연산자`operator[]`는, 배열과 같은 방식으로 객체에 접근할 수 있게 해줍니다.
- `operator[]`를 오버로딩하여, 배열인덱싱 이상의 기능을 제공할 수 있습니다.
	- 예를들어 유형성 검사, 로그기록, 특정조건에서의 값 변환등을 할 수 있겠습ㄴ디ㅏ.
	- 예제처럼 읽기/쓰기 접근제어를 할 수 있습니다.
- 이 연산자는 정수 뿐 아니라, 모든 것을 매개변수로 받을 수 있게 합니다.
```C++
struct A {
char premutation[26] = {'c','b','d','a','h','y'}
char& operator[](char c){
	return permutation[c-'a'];
}

char operator[](char c)const{ // 읽기전용으로 제어하는 경우 입니다. 
return permutation[c-'a'];

}
};

A a;
a['d'] ='t';o

```

### Multidimensional Subscript Operator
- C++23이후로, 다차원 서브스크립트 연산자를 도입하여, 기존의 콤마 연산자의 표준 동작을 대체하게 됩니다. 
```C++
struct A {
    int operator[](int x) { return x; }
};

struct B {
    int operator()(int x, int y) const { return x * y; }
};

int main() {
    A a;
    B b;

    std::cout << "A[3]: " << a[3] << std::endl;           // 단일 인덱스 접근
    std::cout << "B(2, 3): " << b(2, 3) << std::endl;     // 다차원 인덱스 접근

    return 0;
}

```
### Function Call Operator
- 일반적으로, 객체를 함수처럼 동작하도록 만들거나, 클래스의 주요동작을 구현할 때 오버르도됩니다. 
- 아래 코드에서,  operator를 오버로드하여, 두 정수를 곱하는 동작을 구현합니다.
```C++
// std::accumlate는 --<numeric> 헤어데 정의된 함수이며, 함수의 시그니쳐는 다음과 같습니다.
template <class InputIterator, class T>
T accumulate(InputIterator first, InputIterator last, T init);

template <class InputIterator, class T, class BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);

#include <numeric> // for std::accumulate
#include <iostream>

struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};

int main() {
    int array[] = { 2, 3, 4 };
    int factorial = std::accumulate(array, array + 3, 1, Multiply{});
    std::cout << factorial << std::endl; // 24 출력
}

```
### static operator()
- C++ 23에서 함수 호출 연산자`operator()`와 서브스크립트 연산자`operator[]`의 정적 버전을 도입했습니다.
- 이를 통해 `this`포인터를 전달하지 않고도, 연산자를 사용할 수 있게됩니다.
```C++
#include <numeric> // for std::accumulate
#include <iostream>

struct Multiply {
    // 정적 멤버 함수로 정의된 함수 호출 연산자
    static int operator()(int a, int b) {
        return a * b;
    }
};

struct MyArray {
    // 정적 멤버 함수로 정의된 서브스크립트 연산자
    static int operator[](int x) {
        return x * x;
    }
};

int main() {
    int array[] = { 2, 3, 4 };

    // Multiply 객체를 사용하여 accumulate 함수 호출
    int factorial = std::accumulate(array, array + 3, 1, Multiply{});
    std::cout << factorial << std::endl; // 24 출력

    // MyArray 객체를 사용하지 않고 정적 서브스크립트 연산자 호출
    int value = MyArray::operator ;
    std::cout << value << std::endl; // 25 출력

    return 0;
}
```
### Conversion Operator
- 객체를 다른 타입으로 암시적 혹은 명시적으로 캐스팅할수 있도록 합니다.
이를 통해 클래스 객체를 원하는 타입으로 변환할 수 있습니다. 
- 아래 코드예제에서 `operator bool()`형태로 선언하여, Mybool 객체를 bool 타입으로 변환될 수 있도록 합니다.
```C++
class MyBool {
    int x;
public:
    // 생성자
    MyBool(int x1) : x{x1} {}

    // 변환 연산자: 객체를 bool 타입으로 변환
    operator bool() const {
        return x != 0; // x가 0이 아니면 true, 0이면 false 반환
    }
};

int main() {
    MyBool my_bool{3}; // x를 3으로 초기화
    bool b = my_bool;  // MyBool 객체를 bool로 암시적 변환, operator bool() 호출
    std::cout << std::boolalpha << b << std::endl; // false 출력
    return 0;
}


```