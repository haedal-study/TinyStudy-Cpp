
### Parameters
---
* 람다 표현식에서도 파라미터에 `auto`를 사용해 타입을 자동 추론하거나 default parameter를 사용하는 것이 가능하다.
```cpp
auto lambda = [](auto value) {return value * 2;};
auto lambda = [](int value=10) {return value + 4;};

cout << lambda1(12.5f); // print 25
cout << lambda2(); // print 14
```


### Composability
---
* 람다 표현식끼리 결합할 수 있다.
```cpp
auto lambda1 = [](int value) { return value + 4; };
auto lambda2 = [](int value) { return value * 2; };

auto lambda3 = [&](int value) { return lambda2(lambda1(value)); };
```

* 함수가 람다를 반환할 수도 있다. (* dynamic dispatch도 가능함)
```cpp
auto f() {return [] (int value) {return value + 4;};}
```

* dynamic dispatch : 다형성을 사용한 메서드나 함수 구현에서, 런타임에 어떤 메서드(or 함수)를 사용할 지 고르는 프로세스.

```cpp
#include <iostream>
#include <vector>
#include <functional>

class Shape {
public:
    // 람다 표현식으로 세팅 될 변수
    std::function<void()> draw;
	
	// .람다 표현식을 인자로 받음
    Shape(std::function<void()> drawLambda) : draw(drawLambda) {}
    
    void Draw() {
        draw();  // 람다를 호출
    }
};

int main() {
	// 각 객체들에 서로 다른 출력을 내는 람다식을 세팅함
    Shape circle([]() {
        std::cout << "Drawing a circle." << "\n";
        });
	
    Shape rectangle([]() {
        std::cout << "Drawing a rectangle." << "\n";
        });
	
    Shape triangle([]() {
        std::cout << "Drawing a triangle." << "\n";
        });
    
    std::vector<Shape> shapes = { circle, rectangle, triangle };
    
    // 동적으로 객체에 맞는 Draw를 호출함 (dynamic dispatch)
    for (auto& shape : shapes) {
        shape.Draw();
    }
    
    return 0;
}
```


### `constexpr`/`consteval`
---
* C++17부터 람다 표현식에서 `constexpr` 키워드를 사용할 수 있다.
* C++20부터 람다 표현식에서 `consteval` 키워드를 사용할 수 있다.

```cpp
auto factorial = [](int value) constexpr{
	int ret = 1;
	for(int i = 2; i <= value; i++)
		ret *= i;
	return ret;
};
auto mul = [int v] consteval {return v * 2;};

constexpr int v1 = factorial(4) + mul(5); // 34
```