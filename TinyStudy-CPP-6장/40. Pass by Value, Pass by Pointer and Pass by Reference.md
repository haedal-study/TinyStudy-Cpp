
### 함수 Parameter와 Argument의 차이
---

* Parameter : 함수 시그니처의 한 부분으로써, 함수에 뭘 전달해야 할 지 나타낸다.

* Argument : 함수 파라미터에 실제로 전달되는 값.

```cpp
void f(int a, char* b) // a, b가 paremeter
f(3, "ABC"); // 3, "ABC"가 argument
```


### Pass by Value
---
- 변수의 객체(값)이 복사되어 함수의 argument로 할당된다.  `f(T x)`

- 장점 : 함수 내부에서 parameter가 변경되어도 argument에는 영향을 주지 않는다.
- 단점 : 큰 객체가 전달될 경우 많은 복사 비용이 들어 성능 저하가 발생할 수 있다.

- 지향할 사용처
	- 원시타입(`int`, `float` ... )
	- 크기가 작은 객체 (`2 * sizeof(void*)보다 작은 크기의 객체. 64-bit OS = 16 byte`)

- 지양할 사용처
	- 크기가 큰 객체
	- 크기가 큰 배열(배열이 포인터로 감쇠(decay)되어 전달됨.)
```cpp 
// 배열 감쇠(array decay)
// 배열의 차원과 타입이 손실되어 전달된다.
voi foo(int array[]){
	cout << sizeof(array); // print 8
}

int array[5] = {1,2,3,4,5};
cout << sizeof(array); // print 20
foo(array);
```

### Pass by Pointer
---
* 변수의 주소값이 복사되어 함수의 argument에 할당된다. `f(T* x)`

- 장점
	- 함수 내에서 argument를 직접 변경할 수 있다.
	- 크기가 큰 객체를 값 복사 없이 전달할 수 있어 빠르다.
- 단점
	- argument로 null 포인터가 들어올 수 있다.
	- 역참조 연산(`*`)으로 값을 수정하는 것이 직접 값을 수정하는 것보다 느리다.

- 지향할 사용처
	- 일반 배열(readonly 의 경우 `const`)

* 지양할 사용처
	* 나머지 전부

### Pass by Reference
---
* 변수의 참조값이 복사되어 함수의 argument에 할당된다. `f(T& x)`

- 장점
	- 함수 내에서 argument를 직접 변경할 수 있다. (포인터보다 가독성 좋음.)
	- argument의 값이 복사되지 않아 빠르다.
	- null 포인터를 갖지 않아 안전하다.
	- 암시적 형변환을 제한해 안전하다.

* 단점
	* 값을 참조하기 때문에 argument에 변경을 줄 수 있다. (장점이자 단점..?, 값을 변경하면 안 될 때는 const를 붙이자.)

* 지향할 사용처
	* 기본 포인터가 아닌 모든 케이스

* 지양할 사용처
	* Pass by Value 를 사용해도 되는 곳.(Pass by value가 원시타입, 작은 객체의 전달에 있어서는 더 성능이 좋고 가독성있음.)


#### 예시

```cpp
void f1(int a); // pass by value
void f2(int& a); // pass by reference
void f3(int* a); // pass by pointer
void f4(int*& a); // 포인터를 참조로 전달
```

참고자료
[Array Decay In C - GeeksforGeeks](https://www.geeksforgeeks.org/array-decay-in-c/)
