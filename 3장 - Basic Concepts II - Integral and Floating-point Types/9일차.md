# [Signed/Unsigned Integer Characteristics | Promotion, Truncatio]

## Signed/Unsigned Integer Characteristics
- 부호 있는 정수와 부호 없는 정수는 연산에 동일한 하드웨어를 사용하지만 매우 다른 의미를 갖음

Basic concepts

- 오버플로우   
: 산술 연산의 결과가 해당 데이터 유형이 표현할 수 있는 최대값을 초과하는 경우   
: 즉, **양수/음수의 가장 큰 값들을 초과하는 경우**   
: 오버플로우가 발생하면 결과 값은 해당 데이터 유형이 표현할 수 있는 범위를 벗어난 값에서부터 다시 시작됨

- 래핑어라운드   
: 산술 연산의 결과가 해당 데이터 유형의 비트 수에 대한 나머지 연산을 한 결과로 줄어드는 경우를 말함   
: 예를 들어 8비트 정수에서 255에 1을 더하면 0이 됨 (why? 8비트 정수의 범위를 벗어나는 결과이기 때문)   
=> 래핑어라운드는 데이터 유형이 표현할 수 있는 범위를 벗어나는 경우 **해당 범위 내에서 끝으로 되돌아가는 것**을 의미함

### 1) 부호 있는 정수(Signed Integer)
- 양수, 음수 및 0 값을 모두 나타낼 수 있음

- 양수(2^31 − 2)보다 음수(2^31 − 1) 값이 더 많음   
  ** 부호 있는 정수는 음수 값이 있기 때문에 **곱셈, 나눗셈, 나머지 연산을 할 때 주의**가 필요함   

- **오버플로우**나 **언더플로우**가 발생할 수 있음 -> 정의되지 않은 동작으로 이어질 수 있음   
  (가능한 동작 : 오버플로운- (2^31 − 1) + 1 → min / 언더플로우- −2^31 − 1 → max)

- 비트 단위 연산은 구현에 따라 정의됨   
  (e.g. 부호 있는 시프트 → 정의되지 않은 동작)

• 속성
교환법칙, 반사법칙, 결합법칙과 같은 일부 속성은 부호 있는 정수에서는 성립하지 않음
(why? 오버플로우나 언더플로우가 발생할 경우 연산 결과가 예상과 다를 수 있기 때문)

### 2) 부호 없는 정수(Unsigned Integer)
- 오직 음수가 아닌 양수 값을 나타냄

- 부호 없는 정수는 양수 값만을 다루므로 오버플로우나 언더플로우의 문제는 발생하지 않음

- 0과 2^32 −1에서 불연속성이 있음   부호 없는 정수가 음수를 표현할 수 없기 때문에, 0부터 최대값까지의 값들은 양수만을 포함하게 됨   
따라서 최대값인 2^32 −1에 도달할 수에는 다음으로 갈 수 있는 값이 없으며, 다음 값은 다시 0이 됨  
   => 이것이 불연속성을 나타내는 것

- 래핑어라운드 의미 → 잘 정의됨   
(2^32 −1 다음에 바로 0으로 돌아가게 됨)

- 비트 단위 연산은 잘 정의됨
• 속성: 교환법칙, 반사법칙, 결합법칙

## 부호 있는/없는 정수를 언제 사용해야 할까?

해결책: int64_t 사용해라   
최대 값: 2^63 − 1

int64_t와 같은 부호 있는 정수를 사용하여 매우 큰 값이나 음수 값을 나타내는 경우가 있음
그러나, C++ 표준은 컨테이너의 크기를 나타내는 데 부호 없는 정수를 사용하고 있으며, 이는 과거의 실수 때문에 지속되고 있음

### 1) 부호 있는 정수를 사용하는 경우
• 음수 값과 혼합될 수 있는 경우    
: 예를 들어 두 바이트 크기를 빼는 등의 연산을 할 때 부호 있는 정수를 사용함

• 부호 있는 정수와 단언(assertion)을 사용하여 음이 아닌 값을 표현하는 것이 좋음   
: 코드의 가독성과 안전성을 높이는 데 도움이 됨

• 최적화 목적    
: 컴파일러가 루프 등에서 일부 정의되지 않은 동작을 최적화하는 데 도움이 될 수 있음

### 2) 부호 없는 정수를 사용하는 경우
• 양수 값과 혼합될 수 없는 경우 (?)   
: 부호 없는 정수는 음수를 나타낼 수 없기 때문에 양수값과만 사용됨   
: 예를 들어 자연수를 저장하거나 비트 연산을 수행할 때 부호 없는 정수를 사용함

• 비트 마스크 값   
: 부호 없는 정수는 비트 단위 연산에 매우 유용함   
: => 비트 마스크를 만들거나 비트 연산을 수행할 때 자주 사용됨

• 최적화 목적   
: 나눗셈이나 나머지 연산을 수행할 때 부호 없는 정수를 활용하는 것이 좋음

• 안전성이 중요한 시스템   
: 안전성이 중요한 시스템에서는 부호 있는 정수의 오버플로우가 예측할 수 없는 비결정룐적인 동작을 일으킬 수 있음   
: 이러한 경우에는 부호 없는 정수를 사용하여 안전성을 높일 수 있음

## 산술 유형 한계   
- 데이터 형식(정수, 부동 소수점 등)의 범위를 결정하는 데 사용됨    
- 이러한 한계는 컴퓨터 시스템에서 사용 가능한 메모리의 크기와 관련이 있으며, 해당 데이터 형식이 나타낼 수 있는 최소값과 최대값을 정의함

## Promotion and Truncation

프로모션 (Promotion)
- 작은 데이터 유형을 더 큰 데이터 유형으로 변환하는 것을 말함
- 이때 부호가 있는 경우, 부호는 보존됨

~~~cpp
int16_t x = -1;
int y = x; // 더 큰 데이터 유형으로 변환
cout << y; // -1 부호 있는 경우, 부호 보존
~~~

절단 (Truncation)
- 큰 데이터 유형을 작은 데이터 유형으로 변환하는 것을 의미함
- 이때는 더 작은 데이터 유형의 비트 수에 맞게 가장 큰 값으로 나누어 나머지를 취하는 것으로 수행됨

~~~cpp
int x = 65537; // 2ˆ16 + 1
int16_t y = x; // x % 2ˆ16
cout << y; // 1
int z = 32769; // 2ˆ15 + 1 (int16_t과 데이터 유형이 맞지 않음)
int16_t w = z; // (int16_t) (x % 2^16 = 32769)
cout << w; // -32767
~~~

## Mixing Signed/Unsigned Errors

- 값 손실   
: 부호 있는 데이터 유형과 부호 없는 데이터 유형의 크기가 다를 수 있음

- 부호 확장   
: 부호 있는 데이터 유형을 부호 없는 데이터 유형으로 변환할 때 발생할 수 있는 오류

- 비트 연산 오류   
: 부호 있는 데이터 유형과 부호 없는 데이터 유형 간의 비트 연산은 부호 확장과 관련된 문제를 초래할 수 있음








