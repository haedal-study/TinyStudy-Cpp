- Signed/Unsigned Integer Characteristics
	- 기본 개념
		- Overflow: 산술 연산의 결과가 단어 길이, 즉 가장 큰 값의 양수/음수를 초과합니다.
		- Wraparound: 산술 연산의 결과가 모듈로 2N만큼 줄어듭니다. 여기서 N은 단어의 비트 수입니다.
	- Signed
		- 양수, 음수, 0
		- 숫자에 대해 인간의 직관을 표현
		- 주의점
			- 음수 2^31 - 2이 양수 2^31 - 1보다 더 크다
				- 곱하기, 나누기, 모듈로 -1
			- Overflow/underflow semantic
				- overflow (2^31 - 1) + 1 : min
				- undeflow -2^31 - 1 : max
			- 비트 단위 연산은 구현에 따라 정의됩니다
				- signed shift → undefined behavior
		- Properties: commutative, reflexive, not associative (overflow /underflow)
		- 사용하는 경우
			- 음수 값과 혼합할 수 있는 경우(예: 바이트 크기 빼기)
			- 부호 있는 정수와 어설션으로 음수가 아닌 값을 표현하는 것을 선호합니다.
			- 최적화 목적(예: 루프에서 정의되지 않은 동작 활용)
	- Unsigned
		- 음수가 아닌 값
		- 0, 2^32 - 1
		- Wraparound semantic → well-defined (modulo 2^32)
		- 비트 단위의 연산이 잘 정의되어 있다
		- Properties: commutative, reflexive, associative
		- C++ 표준은 부호가 없는 정수를 사용하여 컨테이너 크기를 나타내는데
			- use int64 t
			- max value 2^63 − 1 = 9,223,372,036,854,775,807 or 9 quintillion (9 billion of billion), about 292 years in nanoseconds, 9 million terabytes
		- 사용하는 경우
			- 부호 없는 정수는 언제 사용하나요?
			- 음수 값과 절대 섞일 수 없는 경우
			- 비트 마스크 값
			- 최적화 목적, 예 : 나누기, 모듈로
			- 안전이 중요한 시스템에서 부호 없는 정수 오버플로는 "비결정적"일 수 있습니다.
- Promotion
	- 더 큰 유형으로 승격하면 기호가 유지됩니다.
- Truncation
	- 더 작은 타입으로의 잘림은 더 작은 타입의 비트 수에 대한 모듈로 연산으로 구현됩니다. 
