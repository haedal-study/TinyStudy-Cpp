# [Undefined Behavior]

## 더 많은 음수 값들이 양수 값들보다 존재함

예제 1)
~~~cpp
int x = std::numeric_limits<int>::max() * -1; // (2ˆ31 -1) * -1
cout << x; // -2ˆ31 +1 ok
~~~
최대값에 1을 곱하면 2^31+1이 됨 => 음수의 최소값 여기서 1을 곱하는 것은 부호를 바꾸는 것이므로 음수값이 됨

예제 2)
~~~cpp
int y = std::numeric_limits<int>::min() * -1; // -2ˆ31 * -1
cout << y; // hard to see in complex examples // 2ˆ31 overflow!!
~~~
최소값에 1을 곱하면 2^31이라는 양의 정수값이 예상됨 하지만 이 경우 오버플로우가 발생하여 정확한 결과 예측 어려움   

=> 부호 있는 정수에서는 양수와 음수의 범위가 균형있게 나뉘어 있지 않으며, 특히 최소값의 절대값이 최대값의 절대값보다 1큼 이로 인해 일부 연산에서는 예상치 못한 결과가 발생할 수 있음

## A practical example
~~~cpp
void f(int* ptr, int pos) {
pos++;
if (pos < 0)
return; // <-- the compiler assumes that
ptr[pos] = 0; // signed overflow never happen
} // and removes the if statement
int main() { // compiled with optimizations
int tmp[10]; // leads to segmentation faults
f(tmp, INT_MAX);
}
~~~
이 코드에서는 정수 배열과 배열의 위치를 조작하는 함수가 있음   
이 함수에서 배열의 위치를 증가시킨 후, 그 위치가 음수인지 확인하는 부분이 있는데 여기서 정수가 최대값에 도달한 후에 1을 더하면, 오버플로우가 발생하여 음수값으로 돌아가게 됨.   
=> 음수가 아닌 값을 음수로 바꾸는 것을 ‘부호 있는 정수의 오버플로우’라고 함

컴파일러는 이러한 오버플로우가 발생하지 않을 것이라고 가정하고, 위치가 음수인지 확인하는 부분을 제거하게 됨   
=> 함수는 배열의 잘못된 위치에 0을 할당하려고 시도하게 되고, 이는 메모리 접근 오류를 일으켜 segmentation fault가 발생할 수 있음   

즉, 이 코드는 오버플로우에 대한 검사를 제대로 수행하지 않고, 최적화 과정에서 오류가 발생하여 예상치 못한 결과를 초래할 수 있는 사례를 보여주고 있음

## 정수를 정의할 때, 해당 정수의 범위를 초과하는 값으로 초기화할 수 없음
=> 정의되지 않은 동작!
~~~cpp
int z = 30000000000; // 정의되지 않은 동작!
~~~
이 코드와 같이 너무 큰 값을 사용하여 정수를 초기화하려고 하면, 이는 컴퓨터가 처리할 수 있는 범위를 벗어나게 됨

## 부호 있는 정수 타입에 대한 비트 연산은 정의되지 않은 동작
~~~cpp
int y = 1 << 12;
~~~
이 코드와 같이 부호 있는 정수에 대해 비트 왼쪽 이동 연산을 수행하려고 하면, 이는 컴파일러나 시스템에 따라 동작이 정의되지 않을 수 있음   

==> 부호 있는 정수 타입에 대해 비트 연산을 사용할 때는 예상치 못한 결과가 발생할 수 있으므로 주의해야 함

## 데이터 타입의 비트 수보다 큰 크기로 시프트 연산을 하는 것은 정의되지 않은 동작
~~~cpp
unsinged y = 1u << 32u;
~~~
이 코드와 같이 32보다 큰 크기로 시프트 연산을 시도하면, 컴파일러나 시스템에서 동작이 정의되어 있지 않음   
(why? 데이터 타입의 비트 수를 넘어서는 시프트 연산이 메모리에 영향을 미치는 방식이 정의되지 않기 때문)

## 암시적 변환에서의 정의되지 않은 동작
~~~cpp
uint16_t a = 65535;
uint16_t b = 65535;
cout << (a * b)
~~~
이 코드와 같이 두 16비트 부호 없는 정수에 대한 곱셈 연산을 수행하려고 할 때, 결과가 16비트를 초과할 수 있음   
이 경우, 결과가 32비트로 저장될 필요가 있지만, 정수의 곱셈 연산은 그 자체로는 자동으로 32비트로 확장되지 않음   
이러한 경우, 암시적으로 정수 오버플로우가 발생하고, 이는 정의되지 않은 동작임!

## 가장 안좋은 예제
~~~cpp
#include <iostream>

int main() {
	for (int i = 0; i < 4; ++i)
		std::cout << i * 1000000000 << std::endl;
}
~~~
이 코드는 for문을 이용해서 0부터 3까지의 값을 각각 10억을 곱한 후 출력하고 있음   
이 코드에서는 정수형의 오버플로우가 발생함   
(why? 10억을 32비트 부호 있는 정수로 표현할 수 없기 때문)   
이는 정의되지 않은 동작 -> 프로그램의 결과가 예측 불가능하게 됨

## 루프는 size가 INT_MAX와 같은 경우 안전하지 않음
~~~cpp
void f(int size) {
for (int i = 1; i ‹ size; i += 2)
｝
~~~
이 경우 i가 정수의 최대값에 도달하고 더 이상 증가할 수 없음   
하지만 루프 내용에 따라 정수 오버플로우가 발생함   
=> 정의되지 않은 동작

즉, 오버플로우를 방지하는 것이 중요!   
조건문을 활용하여 오버플로우를 방지할 수 있음

## 부호 없는 정수형에 대한 래핑어라운드 감지는 간단하지 않음
- 덧셈 오버플로우 감지
~~~cpp
bool is_add_overflow (unsigned a, unsigned b) {
return (a + b) ‹ a l| (a + b) < b;
｝
~~~
- 곱셈 오버플로우 감지
~~~cpp
bool is _mul_overflow(unsigned a, unsigned b) f
unsigned x = a * b;
return a != 0 8& (x / a) != b;
｝
~~~
부호 있는 정수형의 경우 오버플로우/언더플로우 감지가 더 복잡함   
연산을 수행하기 전에 반드시 확인해야 함!   
(why? 부호 비트에 대한 고려와 추가적인 비트 조작을 필요로 하기 때문)

