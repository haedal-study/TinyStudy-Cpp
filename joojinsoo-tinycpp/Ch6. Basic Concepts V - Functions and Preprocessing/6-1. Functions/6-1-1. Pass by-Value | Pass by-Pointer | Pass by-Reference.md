# Pass by-Value

## 정의
- 함수에 인수를 전달할 때 객체의 복사본이 생성되어 함수의 매개변수로 할당.
- 함수 내에서 이루어지는 모든 변경이 원본 인수에 영향을 미치지 않는다.

## 장점
- side-effects 방지 가능.
- 함수의 독립성 보장 가능.

## 단점
- 큰 객체 혹은 구조체를 복사할 때 성능 이슈 발생 가능.

## 사용 시기
- 2 * sizeof(void*)보다 작은 크기의 객체에 대해서 사용.
    - 64bits sizeof(void*)는 8bytes

## 절대 사용 금지
- 고정 크기 배열 주의.
    - 전달될 때 포인터로 자동 변환되어 배열의 실제 크기를 알 수 없다.
- 큰 객체
    - 성능 이슈.


# Pass by-Pointer

## 정의
- 함수에 인수를 전달할 때 변수의 주소가 복사되어 함수의 매개변수로 할당된다.
- 함수는 인수의 실제 값을 변경할 수 있다.

## 장점
- 변수의 상태를 직접 조정할 수 있다.
- 인수가 복사되지 않기 때문에, 큰 객체를 전달할 때 효율적.

## 단점
- 전달된 포인터가 null일 수 있어, 함수 내에서 추가적인 검사가 필요할 수 있다.
- 포인터를 역참조하는 것은 직접 값을 접근하는 것보다 느릴 수 있다.
    - 포인터가 가리키는 주소를 메모리에서 읽고, 그 주소로 가서 실제 데이터를 읽어야 하기 때문.

## 사용 시기
- 원본 데이터에 대한 변경이 필요한 경우.
- 크기가 큰 데이터 구조체나 배열을 효율적으로 전달하고자 할 때.
    - 읽기 전용으로 사용할 경우 const T*을 사용.

## 절대 사용 금지
- 포인터가 필요하지 않은 경우, 즉 데이터를 변경할 필요가 없거나, null 포인터의 위험을 줄이고자 할 때.
- 값에 의한 전달로 충분한 경우, 특히 작은 크기의 데이터를 다룰 때.


# Pass by-Reference

## 정의
- 함수에 인수를 전달할 때 변수의 참조가 복사되어 함수의 매개변수로 할당.
- 함수는 인수의 실제 값을 변경할 수 있다.

## 장점
- 변수의 상태를 직접 조정할 수 있습니다.
- 인수가 복사되지 않기 때문에, 큰 객체를 전달할 때 효율적.
- 참조는 반드시 초기화되어야 하므로, null 포인터의 문제가 없다.
- const T&가 아닌 경우, 암시적 타입 변환을 방지할 수 있습니다.

## 사용 시기
- 원본 데이터에 대한 변경이 필요하고, null 포인터의 위험 없이 안전하게 참조를 전달하고 싶은 경우.
- 크기가 큰 데이터 구조체나 객체를 효율적으로 전달하고자 할 때.
    - 읽기 전용 데이터에 대해서는 const T&를 사용.

## 절대 사용 금지
- 객체가 작고 흔히 복사되는 경우.


# 예시

```cpp
#include <iostream>

struct MyStruct {}; // 간단한 구조체 선언

// 값에 의한 전달: 함수 내 변경이 원본에 영향 없음
void f1(int a) {
    // a는 함수 내에서만 유효한 로컬 복사본
}

// 참조에 의한 전달: 함수 내 변경이 원본에 영향
void f2(int& a) {
    // a는 원본 변수에 대한 참조
}

// 상수 참조에 의한 전달: 읽기 전용 접근
void f3(const int& a) {
    // a는 읽기만 가능, 수정 불가
}

// 구조체 참조에 의한 전달
void f4(MyStruct& a) {
    // a는 원본 MyStruct에 대한 참조
}

// 포인터에 의한 전달: 주소 복사
void f5(int* a) {
    // a는 포인터, 원본 데이터 변경 가능
}

// 상수 포인터에 의한 전달: 데이터 변경 불가
void f6(const int* a) {
    // a는 데이터를 변경할 수 없는 포인터
}

// 구조체 포인터에 의한 전달
void f7(MyStruct* a) {
    // a는 MyStruct 객체의 포인터
}

// 포인터의 참조에 의한 전달: 포인터 자체 변경 가능
void f8(int*& a) {
    // a는 int 포인터의 참조, 포인터 변경 가능
}

int main() {
    char c = 'a';
    f1(c);  // 값에 의한 전달, c는 int로 암시적 변환
    // f2(c);  // 컴파일 에러: 타입 불일치
    f3(c);  // 상수 참조 전달, c는 int로 암시적 변환

    return 0;
}
```
