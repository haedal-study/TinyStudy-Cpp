# 참조

- 변수 참조는 기존에 존재하는 변수에 대한 별명과도 같다.
- 포인터는 스택에 자신의 메모리 주소와 크기를 가지지만, 참조는 원본 변수와 동일한 메모리 주소를 공유한다.
- 컴파일러는 내부적으로 참조를 포인터로 구현할 수 있지만, 참조와 포인터를 매우 다른 방식으로 처리한다.

## 이점
- 포인터보다 안전하다.
    - NULL값이 될 수 없다.
    - 변경되지 않는다.
    - 생성 시 반드시 초기화되어야 한다.

## 예제

### 기본
```cpp
// int& a; // 컴파일 오류: 초기화 없음
// int& b = 3; // 컴파일 오류: "3"은 변수가 아님
int c = 2;
int& d = c; // 참조. 유효한 초기화
int& e = d; // 참조의 참조는 여전히 참조
++d; // 증가 연산
++e; // 증가 연산
cout << c; // 4를 출력
```

### 포인터와 차이점
```cpp
int a = 3;
int* b = &a; // 포인터
int* c = &a; // 포인터
++b; // 포인터 'b'의 값을 변경
++*c; // 'a'의 값을 변경 (a = 4)
int& d = a; // 참조
++d; // 'a'의 값을 변경 (a = 5)
```

### 함수 인자로서의 참조와 포인터
```cpp
void f(int* value) {} // value는 nullptr일 수 있음
void g(int& value) {} // value는 절대 nullptr이 아니다

int a = 3;
f(&a); // ok
f(0); // 위험하지만 작동 (다른 숫자들로는 작동하지 않음)
// f(a); // 컴파일 오류: "a"는 포인터가 아니다
g(a); // ok
// g(3); // 컴파일 오류: "3"은 어떤 것의 참조가 아니다
// g(&a); // 컴파일 오류: "&a"는 참조가 아니다
```

### 고정 크기 배열을 인자로 사용하는 참조
```cpp
void f(int (&array)[3]) { // 크기가 3인 배열만 받는다
    cout << sizeof(array);
}

void g(int array[]) {
    cout << sizeof(array);
}

int A[3], B[4];
int* C = A;
```

### 참조 - 배열
```cpp
int A[4];
int (&B)[4] = A; // A 배열에 대한 참조. 참조 B는 배열 A를 가리킨다

int C[10][3];
int (&D)[10][3] = C; // C 배열에 대한 참조. 참조 D는 배열 C를 가리킨다

auto c = new int[3][4]; // c의 타입은 int (*)[4]. 즉, 4개의 int를 가진 배열에 대한 포인터

int array[4];
int size1 = (&array)[1] - array; // 컴파일 오류가 예상되지만, 의도를 설명하기 위한 예제
int size2 = *(&array + 1) - array;
cout << size1; // 4를 출력하려는 의도
cout << size2; // 실제로 4를 출력
```
