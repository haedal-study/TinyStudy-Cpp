# C++20 Concepts

## 정의
- C++20에서 도입된 개념으로, 템플릿에 대한 제약 조건을 강제하여 템플릿 인자에 대한 요구 사항을 명시.
- 컴파일 타임에 템플릿 인자의 유효성을 검사할 수 있도록 한다.

## 장점
- SFINAE (std::enable_if)에 비해 읽기 쉽고 쓰기 쉬움.
- 디버깅을 위한 명확한 컴파일 타임 메시지 제공.
- 더 빠른 컴파일 타임.

## 이를 달성하기 위해 사용되는 키워드
- concept: 개념을 정의할 때 사용.
- requires: 제약 조건 목록, 요구 사항, 절 및 표현식을 명시할 때 사용.

### 예시
- 목표: 산술 타입만 더하는 함수를 정의.

```cpp
template<typename T>
T add(T valueA, T valueB) {
    return valueA + valueB;
}

struct A {};

int main() {
    std::cout << add(3, 4) << std::endl; // ok
    // std::cout << add(A{}, A{}) << std::endl; // 지원되지 않음
    return 0;
}
```

- SFINAE를 사용한 해결책 (지저분하고 장황)

```cpp
#include <type_traits>

template<typename T>
std::enable_if_t<std::is_arithmetic_v<T>, T>
add(T valueA, T valueB) {
    return valueA + valueB;
}

struct A {};

int main() {
    std::cout << add(3, 4) << std::endl; // ok
    // std::cout << add(A{}, A{}) << std::endl; // 컴파일 오류
    return 0;
}
```

- Concepts를 사용하여 보다 간결하고 명확하게 템플릿 제약 조건을 정의할 수 있다.

```cpp
#include <concepts>
#include <iostream>

// 'Arithmetic' 개념을 정의하여 산술 타입만 허용
template<typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

template<Arithmetic T>
T add(T valueA, T valueB) {
    return valueA + valueB;
}

struct A {};

int main() {
    std::cout << add(3, 4) << std::endl; // ok
    // std::cout << add(A{}, A{}) << std::endl; // 컴파일 오류: 'A'는 'Arithmetic' 개념을 만족하지 않음
    return 0;
}
```

```cpp
```

```cpp
```

```cpp
```

```cpp
```

```cpp
```

```cpp
```

