# [Conversion Rules]
## 데이터 타입 간의 암시적인 변환 규칙
이 규칙들은 연산을 수행하기 전에 적용되며 다음과 같은 순서로 적용됨

- 부동 소수점 프로모션
  
  : **부동 소수점 타입과 정수 타입** 간의 연산 시, 정수 타입이 **부동 소수점 타입**으로 자동 변환됨

- 암시적 정수 프로모션

  : 작은 정수 타입은 **int 타입**으로 자동 변환됨

  : 작은 정수 타입 간의 연산 시에는 int로 자동 변환됨

- 크기 프로모션
  
  : 작은 타입과 큰 타입이 연산될 때, 작은 타입이 **큰 타입**으로 자동 변환됨

- 부호 프로모션
  
  : signed와 unsigned 타입이 함께 연산될 때, **unsigned 타입**으로 자동 변환됨

~~~cpp
float f= 1.0f;
unsigned u= 2;
int i= 3;
short s= 4;
uint8_t c= 5; //unsigned char

f * u; // float X unsigned -> float: 2.0f
s * c; // short X unsigned char -> int: 20
u * i; // unsigned X int -> unsigned: 6u
+c; // unsigned char -> int: 5

// 정수는 부동 소수점이 아님
int b = 7;
float a = b / 2; // a의 값은 3, 3.5가 아님
int c = b / 2.0; // c의 값은 3, 3.5가 아님
~~~

- 32비트보다 작은 정수 데이터 타입은 signed나 unsigned인 경우에 **int로 암시적으로** 프로모션 됨

그 외의 규칙으로는 단항 및 이항 연산자 (+, -, ~, &, 등)에서의 프로모션
~~~cpp
char a = 48; // 0
cout << a; // 0
cout << +a; // 48
cout << (a + 0); // 48

uint8_t a1 = 255;
uint8_t b1 = 255;
cout << (a1 + b1); // 510
~~~

## auto 키워드를 통한 변수 선언

- auto Keyword
  C++11 auto는 변수의 타입을 컴파일러가 초기값을 통해 자동으로 추론하도록 지정하는 키워드임
  ~~~cpp
  auto a = 1 + 2; // 1은 int, 2는 int, 1 + 2는 int ==> a는 int
  auto b = 1 + 2.0; // 1은 int, 2.0은 double, 1 + 2.0은 double ==> b는 double
  ~~~
  이것은 유지 보수성과 복잡한 타입 정의를 숨기는 데 유용하지만, 과도하게 사요할 경우 코드의 가독성을 저해할 수 있음

## Functions
- C++11/C++14에서 auto 및 decltype 을 사용하여 함수의 출력 타입을 정의할 수 있음
- C++20, auto를 사용하여 함수의 입력 타입도 정의할 수 있음
