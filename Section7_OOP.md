### 7.1.1 구조체와 클래스
    - 구조체와 클래스는 의미적으론 동일하지만 다음과같은 차이점이 있습니다.
        - 구조체는 수동적인 객체, 즉 물리적인 상태 혹은 데이터 집합을 의미합니다. 
        - 반면 클래스는 능동적인 객체를 말하며, 논리적인 상태를 말합니다. 데이터 추상화를 나타낸다고 표현하기도 합니다.


참고: https://banaba.tistory.com/34
### 7.1.2 RAII 
    - Resource Acquisition is Initalization 의 약자이며, 리소스관리를 단순하고 안전하게 하기위한 설계패턴을 의미합니다.
    - 리소스의 생성(획득 및 초기화), 사용, 해제 단계로 이루어집니다. 
        -리소스 생성 (리소스를 클래스에 캡슐화 하기)
            - 리소스(메모리,파일 핸들, 소켓 등)를 객체의 생성자에서 획득하고 초기화합니다.
            - 예를들어 파일을 열거나 메모리를 할당하는 작업은 객체의 생성자에서 수행됩니다.
        - 리소스 사용 (로컬 인스턴스 사용하기)
            - 리소스는 객체의 메서드를 통해 사용되며, 객체가 살아있는동안 안전하게 리소스를 사용할 수 있습니다.
        - 리소스 해제 (객체가 범위를 벗어나면 자동으로 리소스 해제하기)
            - 객체가 더 이상 필요없어서 범위를 벗어나면, 객체의 **소멸자**가 자동으로 호출됩니다.
            - 소멸자는 리소스를 해제하는데 사용되는데, 파일을 닫거나 메모리를 해제하는 작업은 소멸자에서 수행됩니다.
        - C++ 은 가바지 컬렉터가 없으며,  프로그래머가 리소스를 관리할 책임을 가집니다. 이는 추후 메모리누수 개념과 밀접한 관련이 있습니다.


### 7.1.3 Class Hierachy
    1. Child/Derived Class or Subclass
        새로운 클래스가 다른 클래스의 함수와 변수를 상속받으면, 파생혹은 자식클래스라고 부릅니다.
    2. Parent/Base Class
        위의 파생 혹은 자식클래스에게 함수와 변수를 제공하는 **가장 가까운** 클래스를 부모 또는 기본클래스라고 합니다
        cf. 가장가깝지 않은경우, 예를들어 (A<-B<-C) 상속구조인 경우 A는 C의 조상클래스(Ancestor Class)라고 부릅니다. 

        ```
        struct A{
            int value =3;
            vold g() {}
        };

        struct B : A{
            int data = 4;
            int f(){return data;}
        };


        b.g(); // A의 멤버함수
        ```
    3. C++의 구조체와 클래스에서 상속 및 함수호출시 복사와 참조에 관한 다양한 코드예제
    ```
    struct A {};
    struct B : A{};
    void f(A a) {}
    void g(B b) {}
    void f_ref(A& a){}
    void g_ref(B& b){}

    A a;
    B b;

    f(a); // f는 타입 A를 받음
    f(b); // B는 A를 상속받았고, B 타입 객체를 A타입으로 복사하여 호출

    f_ref(a);
    g_ref(b);

    //g(a) : g는 A타입을 받을 수 없기때문에 컴파일 에러가 발생합니다.
    // g_ref(a) : g_ref는 A타입 참조를 받을 수 없습니다.
    g(b);

    A a1 = b; // B는 A를 상속받았기 때문에, B타입 객체를 A타입으로 복사하여 초기화가 가능합니다.
    A& a2 = b;// 이 또한 타입참조 바인딩(참조변수를 다른 변수에 연결하는 것)이 가능합니다 
    // B b1 = a; // 하지만 반대로,A 타입 객체 a를 타입 객체로 복사하는 것은 불가능 합니다.   

    int main() {
    B b; 
    b.value = 10;

    A a1 = b; // B는 A를 상속받았기 때문에, B타입 객체를 A타입으로 복사하여 초기화가 가능합니다.
    A& a2 = b;// 타입참조 바인딩(참조변수를 다른 변수에 연결)
    std::cout <<"current Value" << a2.value << std::endl; //10
    b.value = 15;
    std::cout <<"Modified Value" << a2.value << std::endl; //15 
}
    ```

### 7.1.3 Access Specifier 접근한정자
    - 접근 지정자는 상속된 맴버의 가시성을 정의합니다. 데이터은닉 개념과 관련이 있습니다.
        - public: 제한없음, protected : 함수맴버와 파생클래스에서 접근가능, private 함수멤버만 접근가능
    - struct는 기본적으로 public 맴버이며, class는 기본적으로 private 맴버입니다. 
        - 참고(배경)
            - struct는 데이터 그룹화가 기본 용도였으며, 기본적으로 모두 공개여야 데이터를쉽게 접근하고 사용할 수 있었기 떄문에 기본적으로 public이 되었습니다.
            - 반면, class는 객체지향 프로그래밍을 지원하기 위한 개념이었으며, 데이터 은닉과 캡슐화를 통해, 객체의 내부상태를 보호하고, 접근을 제어하기 위해 기본적으로 private  설정이 되어있습니다. 