## Variable Initialization
```
int a1; // 기본 초기화 (값이 정해지지 않음)

int a2(2); // 직접(혹은 값) 초기화
int a3(0); // 직접(혹은 값) 초기화 (0으로 초기화)
//int a4(); // a4는 함수

int a5 = 2; // 복사 초기화
int a6 = 2u; // 복사 초기화 (암시적 변환)
int a7 = int(2); // 복사 초기화
int a8 = int(); // 복사 초기화(0으로 초기화)

int a9 = {2}; // 복사 리스트 초기화
```
## Uniform Initialization
- C++11 에서 유니폼 초기화 구문은, 중괄호 초기화나 중괄호 초기화 리스트라고도 불리는데, 이는 각각 다른 엔티티를 초기화할 수 있게 해준다.
```
int b1{2}; // 직접 리스트(혹은 값) 초기화
int b2{}; // 직접 리스트(혹은 값) 초기화(0으로 초기화)

int b3 = int{}; // 복사 초기화(0으로)
int b4 = int{4}; // 복사 초기화

int b5 = {}; // 복사 리스트 초기화
```
- 얻을 수 있는 이점
	- 안전하게 산술 유형을 바꿀 수 있다.
	- 암시적 축소를 방지할 수 있다. (값을 잃을 수도 있기 때문)
	- 현대 케스팅 보다는 더 단순해졌다.
```
int b4 = -1; // 가능
int b5{-1}; // 가능
unsigned b6 = -1; // 가능
//unsigned b7{-1}; // 컴파일 에러

float f1{10e30}; //가능
float f2 = 10e40; // 가능, inf 값으로 들어감
///float f3{10e40}; // 컴파일 러러
```
## Fixed-Size Array Initialization
- 1차원
```
int a[3] = {1, 2, 3}; // 명시적인 크기
int b[] = {1, 2, 3}; // 암시적인 크기
char c[] = "abcd"; // 암시적인 크기
int d[3] = {1, 2}; // 마지막 값은 0(디폴트)값이 들어감

int e[4] = {0}; // 모든 값이 0으로 초기화됨
int f[3] = {}; // 모든 값들은 0으로 초기화됨
int g[3] {}; // 모든 값들이 0으로 초기화됨
```
- 2차원
```
int a[][2] = { {1, 2}, {3, 4}, {5, 6}}; //가능
int b[][2] = { 1, 2, 3, 4}; // 가능
// a와 b의 타입은 int[]의 배열 타입이다.
// int c[][] = ...; // 컴파일 에러
// int d[2][] = ...; // 컴파일 러러
```