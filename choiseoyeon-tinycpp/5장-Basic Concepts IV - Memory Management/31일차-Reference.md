## Reference
- 변수 레퍼런스 `T&`는 별칭으로, 이미 존재하는 변수에 대한 다른 이름이다.
- 변수와 변수 레퍼런스 모두 해당 변수의 값을 가리키기 위해 사용될 수 있다.
- 포인터는 자신만은 스택에서의 공간과 자신만의 메모리 주소를 갖고 있지만, 레퍼런스는 원래 변수와 같은 메모리 주소를 사용한다.
- 컴파일러는 레퍼런스를 내부적으로 포인터로 구현할 수는 있지만, 다른 방식으로 그들을 다룬다
- 레퍼런스는 포인터보다 더 안전하다
	- 레퍼런스는 NULL 값을 가질 수 없다. 항상 진짜로 있는 공간과 연결되어 있다고 생각해야한다.
	- 레퍼런스는 변경될 수 없다. 레퍼런스는 한번 초기화 되면, 다른 변수를 가리키도록 변경될 수 없다
	- 레퍼런스는 만들어질 때 항상 초기화가 같이 되어야 한다.
```
//int& a; // 컴파일 에러, 초기화 안됨
//int& b = 3; // 컴파일 에러, 3은 변수가 아님
int c = 2;
int& d = c; // 합당한 초기화
int& e = d; // 레퍼런스의 레퍼런스도 레퍼런스임...
++d;
++e;
cout << c; // 4
--------------------
int a = 3;
int* b = &a; // 포인터
int* c = &a; // 포인터
++b; // 포인터 b의 값을 변경함
++*c; // a의 값을 변경함(a=4)
int& d = a; // 레퍼런스
++d; // a의 값을 변경함(a=5)

---------------------
// 레퍼런스 vs 포인터 매개변수
void f(int* value) {} // 값이 nullptr일 수 있음

void g(int& value) {} // 값이 nullptr일 수 없음

int a = 3;
f(&a); // 가능
f(0); // 위험하지만.. 가능은 함
//f(a); // 컴파일러 에러

g(a); // 가능
//g(3); // 불가능
//g(&a); // 불가능

--------------------------------
// 레퍼런스는 고정 크기 배열을 가리키기 위해 사용될 수 있음
void f(int (&array) [] ) {
	// 크기가 3인 배열만 가능함
	cout << sizeof(array);
}
void g(int array[]) {
	cout << sizeof(array);
}

int A[3], B[4];
int * c = A

f(A); // 가능
// f(B); // 크기가 3이 아님
// f(c); // C는 포인터
g(A);
g(B);
g(c);

----------------------------------
int A[4];
int (&B)[4] = A; // 배열에 대한 레퍼런스
int C[10][3];
int (&D) [10][3] = C; // 2차원 배열에 대한 레퍼런스

auto c = new int[3][4]; // int (*)[4] 타입
// 요소가 4인 배열에 대한 포인터로 읽어옴
// int (&d)[3][4] = c; // 컴파일 에러
// int (*e)[3] = c; // 컴파일 에러
int (*f)[4] = c; // 가능

int array[4];
// 크기가 4인 배열에 대한 포인터
int size1 = (&array)[1] - array;
int size2 = (&array + 1) - array;
cout << size1; // 4출력
cout << size2; // 4출력
```