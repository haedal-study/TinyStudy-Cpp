# Signed/Unsigned Integer Characteristics
- Signed와 Unsigned는 그들의 연산을 위해 같은 하드웨어르 ㄹ사용하지만, 아주 다른 의미를 갖고 있다.
- 오버 플로우
	- 산수 연산 결과가 범위를 초과한 것의 결과
- Wraparound
	- 산수 연산 결과가 2의 n승(n은 비트수)만큼 줄어드는 것
	- unsigned에서 255 +1을 하면 다시 0으로 돌아가는 것
### Signed Integer
- 양수, 음수, 0을 표현
- 음수가 양수보다 하나 더 많음
	- 2의 보수
- 오버플로우/언더플로우는 정의 되지 않은 연산이다
	- 오버플로우가 발생되면 최소 값이 나온다
	- 언더플로우가 발생하면 최대 값이 나온다
### Unsigned Integer
- 음수가 아닌 수만 표현
- Wraparound와 비트 연산이 가능하다
### Signed과 Unsigned 타입을 사용처
- 기본 C++에서는 unsigned 정수 타입을 컨테이너의 크기를 표현하기 위해 사용한다
	- 이미 오랫동안 이렇게 쓰여와서 이제 와서 바꾸기 어려움...
#### Signed 타입의 사용처
- 음수 값이 사용될 수 있을 때
- 최적화를 위해서 사용될 때
#### Unsigned 타입의 사용처
- 음수 값이 사용되지 않을 때
- 비트 마스크
- 최적화를 위해(나누기 등)
- 안전성이 보장되어야 할 때
---
# Promotion and Truncation
- 프로모션을 할때는 sign을 유지한다
```
int 16_t x = -1;
int y = x; // sign을 유지
cout << y; // -1
```
- 축소 될 때는 더 작은 타입의 비트 수에 기반하여 연산이 일어난다.
```
int x = 65537; // 2의 16승보다 1 큰 값
int16_t y = x; // x를 2의 16으로 나눈 나머지 값이 들어감
cout << y; // 1출력

int z = 32769; //2의 15승보다 1 큰 값(int16_t에 들어가지 않음)
int16_t w = z; // x를 2의16승으로 나눈 값을 int16_t로 형변환
cout << w; // -32767 출
```